<!DOCTYPE html>
<html>
<head>
  <title>Traffic Simulation</title>
  <style>
    body {
      background-color: #f0f0f0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      margin: 0;
      padding: 20px;
      font-family: sans-serif;
    }
    canvas {
      border: 1px solid black;
      display: block;
      margin: 0 auto;
      background-color: white;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    button {
      display: block;
      margin: 10px auto;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      border: none;
      background-color: #4CAF50;
      color: white;
      border-radius: 5px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      transition: background-color 0.3s;
    }
    button:hover {
        background-color: #45a049;
    }
  </style>
</head>
<body>
  <canvas id="trafficCanvas" width="1300" height="900"></canvas>
  <button onclick="resetSimulation()">Reset Simulation</button>
  <button id="toggleSimulationButton" onclick="toggleSimulation()">Stop Simulation</button>

<script>
  const canvas = document.getElementById('trafficCanvas');
  const ctx = canvas.getContext('2d');
  const ROAD_WIDTH = 80 * 1.5;
  const CAR_SCALE = 0.1 * 1.5;
  const CAR_LENGTH = 518 * CAR_SCALE;
  const WHEELBASE = (409 - 94) * CAR_SCALE;
  const centerX = 650;
  const centerY = 450;
  const STEERING_GAIN = 0.5;
  const LOOK_AHEAD_DISTANCE = 90;
  const SYMMETRIC_MAX_TURN_STEER_ANGLE = Math.PI / 5;
  const LOG_HEADING_THRESHOLD_DEG = 5;
  const LOG_DISTANCE_THRESHOLD_PX = 25;
  const UPWARD_LANE_X = centerX + ROAD_WIDTH / 4;
  const DOWNWARD_LANE_X = centerX - ROAD_WIDTH / 4;
  const MAX_CENTRIFUGAL_FORCE = 0.01;
  const MAX_ACCELERATION = 0.08;
  const SPEED_SMOOTHING_FACTOR = 0.1;
  const STEERING_SMOOTHING_FACTOR = 0.1;
  const REJOIN_BUFFER_DISTANCE = ROAD_WIDTH;
  const DEBUG_LOG = false; // Enabled for debugging
  const USE_INTUITIVE_TURN_SIGNAL = true;
  const BLINKER_CYCLE_MS = 500;
  const BLINKER_ON_MS = BLINKER_CYCLE_MS / 2;
  const LOOK_AHEAD_CAR_LENGTHS = 3.0; // Increased to 2.0 for smoother behavior
  const YIELD_TIMEOUT = 5000; // 5 seconds timeout for yielding
  const CROSSROAD_SAFETY_DISTANCE = 2.0; // Number of car lengths

  // Car objects
  let car1 = {
    angle: 0,
    a: 560 + ROAD_WIDTH / 4,
    b: 360 + ROAD_WIDTH / 4,
    maximumSpeed: 0.05,
    speed: 0.05,
    currentSpeedFactor: 1.0,
    x: 0, y: 0,
    rearX: 0, rearY: 0, frontX: 0, frontY: 0,
    heading: 0,
    steerAngle: 0,
    targetSteerAngle: 0,
    lastLoggedHeading: 0,
    lastLoggedX: 0, lastLoggedY: 0,
    path: "ellipse",
    verticalDirection: null,
    direction: -1, // Clockwise
    nextTurnIsLeft: false,
    rejoinBuffer: 0,
    turnState: null,
    willTurn: false,
    canDecide: true,
    isYielding: false,
    yieldStartTime: 0 // Track when yielding started
  };

  let car2 = {
    angle: Math.PI,
    a: 560 - ROAD_WIDTH / 4,
    b: 360 - ROAD_WIDTH / 4,
    maximumSpeed: 0.05,
    speed: 0.05,
    currentSpeedFactor: 1.0,
    x: 0, y: 0,
    rearX: 0, rearY: 0, frontX: 0, frontY: 0,
    heading: -Math.PI / 2,
    steerAngle: 0, targetSteerAngle: 0,
    lastLoggedHeading: -Math.PI / 2,
    lastLoggedX: 0, lastLoggedY: 0,
    path: "ellipse",
    verticalDirection: null,
    direction: 1, // Counter-clockwise
    nextTurnIsLeft: false,
    rejoinBuffer: 0,
    turnState: null,
    willTurn: false,
    canDecide: true,
    isYielding: false,
    yieldStartTime: 0
  };

  let car3 = {
    angle: Math.PI / 2,
    a: 560 + ROAD_WIDTH / 4,
    b: 360 + ROAD_WIDTH / 4,
    maximumSpeed: 0.05,
    speed: 0.05,
    currentSpeedFactor: 1.0,
    x: 0, y: 0,
    rearX: 0, rearY: 0, frontX: 0, frontY: 0,
    heading: Math.PI,
    steerAngle: 0,
    targetSteerAngle: 0,
    lastLoggedHeading: Math.PI,
    lastLoggedX: 0, lastLoggedY: 0,
    path: "ellipse",
    verticalDirection: null,
    direction: -1, // Clockwise
    nextTurnIsLeft: false,
    rejoinBuffer: 0,
    turnState: null,
    willTurn: false,
    canDecide: true,
    isYielding: false,
    yieldStartTime: 0
  };


      let car4 = {
    angle: Math.PI / 2,
    a: 560 - ROAD_WIDTH / 4,
    b: 360 - ROAD_WIDTH / 4,
    maximumSpeed: 0.05,
    speed: 0.05,
    currentSpeedFactor: 1.0,
    x: 0, y: 0,
    rearX: 0, rearY: 0, frontX: 0, frontY: 0,
    heading: Math.PI,
    steerAngle: 0,
    targetSteerAngle: 0,
    lastLoggedHeading: Math.PI,
    lastLoggedX: 0, lastLoggedY: 0,
    path: "ellipse",
    verticalDirection: null,
    direction: 1, // Counter-clockwise
    nextTurnIsLeft: false,
    rejoinBuffer: 0,
    turnState: null,
    willTurn: false,
    canDecide: true,
    isYielding: false
  };

  // Add car5
  let car5 = {
    angle: Math.PI / 2, // Start at the bottom of the ellipse
    a: 560 + ROAD_WIDTH / 4, // Same lane as car1 and car3
    b: 360 + ROAD_WIDTH / 4,
    maximumSpeed: 0.05,
    speed: 0.05,
    currentSpeedFactor: 1.0,
    x: 0, y: 0,
    rearX: 0, rearY: 0, frontX: 0, frontY: 0,
    heading: 0, // Initial heading
    steerAngle: 0,
    targetSteerAngle: 0,
    lastLoggedHeading: 0,
    lastLoggedX: 0, lastLoggedY: 0,
    path: "ellipse",
    verticalDirection: null,
    direction: -1, // Clockwise (same as car1 and car3)
    nextTurnIsLeft: false,
    rejoinBuffer: 0,
    turnState: null,
    willTurn: false,
    canDecide: true,
    isYielding: false,
    yieldStartTime: 0
  };

let car6 = {
    angle: 0, // Start at the bottom of the ellipse
    a: 560 + ROAD_WIDTH / 4, // Right side of the elliptical road
    b: 360 + ROAD_WIDTH / 4,
    maximumSpeed: 0.05,
    speed: 0.05,
    currentSpeedFactor: 1.0,
    x: 0, y: 0,
    rearX: 0, rearY: 0, frontX: 0, frontY: 0,
    heading: 0, // Initial heading, will be adjusted by physics
    steerAngle: 0, targetSteerAngle: 0,
    lastLoggedHeading: 0,
    lastLoggedX: 0, lastLoggedY: 0,
    path: "ellipse",
    verticalDirection: null,
    direction: -1, // Clockwise
    nextTurnIsLeft: false,
    rejoinBuffer: 0,
    turnState: null,
    willTurn: false,
    canDecide: true,
    isYielding: false,
    yieldStartTime: 0
};

  const spriteSheet = new Image();
  spriteSheet.src = 'https://vita2048.github.io/CityTrafficSimulator/CarSpritesheetLights.png';

  let animationFrameId = null;
  let isSimulationRunning = true;

  function drawBackground() {
    ctx.fillStyle = 'rgb(20, 140, 20)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  function drawRoad() {
    ctx.strokeStyle = '#666';
    ctx.fillStyle = '#666';
    ctx.lineWidth = ROAD_WIDTH;
    ctx.beginPath();
    ctx.ellipse(centerX, centerY, 560, 360, 0, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(centerX, 40);
    ctx.lineTo(centerX, 760);
    ctx.stroke();
  }

  function drawDashedEllipse(x, y, a, b) {
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.setLineDash([15, 15]);
    ctx.beginPath();
    ctx.ellipse(x, y, a, b, 0, 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  function drawDashedLine(x1, y1, x2, y2) {
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.setLineDash([15, 15]);
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.setLineDash([]);
  }


  function getDistance(carA, carB) {
    return Math.hypot(carA.x - carB.x, carA.y - carB.y);
  }

function checkCollisionRisk(car, otherCar) {
    const safeDistance = CAR_LENGTH * LOOK_AHEAD_CAR_LENGTHS;
    const distance = getDistance(car, otherCar);
    let isAhead = false;
    let relativeVelocity = 0; // Initialize relativeVelocity

    if (car.path === "ellipse" && otherCar.path === "ellipse") {
      const sameLane = Math.abs(car.a - otherCar.a) < ROAD_WIDTH / 2;
      const sameDirection = car.direction === otherCar.direction;
      if (sameLane && sameDirection) {
        if (car.direction === 1) { // CCW
          let angleDiff = otherCar.angle - car.angle;
          if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
          isAhead = angleDiff > 0 && angleDiff < Math.PI;
        } else { // CW
          let angleDiff = car.angle - otherCar.angle;
          if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
          isAhead = angleDiff > 0 && angleDiff < Math.PI;
        }
      }
    } else if (car.path === "vertical" && otherCar.path === "vertical") {
      const sameDirection = car.verticalDirection === otherCar.verticalDirection;
      if (sameDirection) {
        isAhead = (
          (car.verticalDirection === "up" && otherCar.y < car.y) ||
          (car.verticalDirection === "down" && otherCar.y > car.y)
        );
      }
      // NOTE: Cars on the vertical road traveling in opposite directions are in separate lanes.
      // They do not need to check for collisions with each other here.
      // Intersection logic handles yielding when rejoining the ellipse.
    } else if (car.path === "vertical" && otherCar.path === "ellipse") {
      const isRejoiningTop = car.verticalDirection === "up" && car.y < centerY - car.b + ROAD_WIDTH * 1.5;
      const isRejoiningBottom = car.verticalDirection === "down" && car.y > centerY + car.b - ROAD_WIDTH * 1.5;
      if (isRejoiningTop || isRejoiningBottom) {
        const intersectionY = isRejoiningTop ? centerY - car.b : centerY + car.b;
        const timeToIntersection = Math.abs((car.y - intersectionY) / (car.maximumSpeed * 50 * car.currentSpeedFactor));
        const otherCarAngle = otherCar.angle + otherCar.direction * otherCar.maximumSpeed * 50 * otherCar.currentSpeedFactor * timeToIntersection;
        const otherCarX = centerX + otherCar.a * Math.cos(otherCarAngle);
        const otherCarY = centerY + otherCar.b * Math.sin(otherCarAngle);
        const distanceToIntersection = Math.hypot(otherCarX - centerX, otherCarY - intersectionY);
        isAhead = distanceToIntersection < ROAD_WIDTH && distance < safeDistance * 0.75;
      }
    } else if (car.path === "ellipse" && otherCar.path === "vertical") {
      // A car on the ellipse has the right-of-way over a car on the vertical road waiting to join.
      // The vertical car's own logic handles the yielding behavior. The ellipse car should not
      // consider the vertical car as an obstacle to be avoided, as this can cause deadlocks
      // where both cars wait for each other. isAhead = false;
    }

    let collisionRiskDetected = distance < safeDistance && isAhead; // Original collision risk determination

    // New logic to handle cars turning left from ellipse onto vertical road yielding to straight traffic
    if (car.path === "ellipse" && car.willTurn && car.nextTurnIsLeft) { // 'car' is on ellipse and intends to turn left
        if (otherCar.path === "ellipse") { // 'otherCar' is also on the ellipse
            // Check if both cars are approaching the *same* crossroad relevant for left turns
            // Scenario for Car3 (turning left at top crossroad) and Car2 (approaching top crossroad straight)
            const isCarApproachingTopCrossroadTurn = car.y < centerY - car.b + LOOK_AHEAD_DISTANCE && car.x > centerX && car.direction === -1;
            const isOtherCarApproachingTopCrossroadStraight = otherCar.y < centerY - otherCar.b + LOOK_AHEAD_DISTANCE && otherCar.x < centerX && otherCar.direction === 1;

            // Scenario for bottom crossroad (for completeness)
            const isCarApproachingBottomCrossroadTurn = car.y > centerY + car.b - LOOK_AHEAD_DISTANCE && car.x > centerX && car.direction === 1;
            const isOtherCarApproachingBottomCrossroadStraight = otherCar.y > centerY + otherCar.b - LOOK_AHEAD_DISTANCE && otherCar.x < centerX && otherCar.direction === -1;

            if ((isCarApproachingTopCrossroadTurn && isOtherCarApproachingTopCrossroadStraight) ||
                (isCarApproachingBottomCrossroadTurn && isOtherCarApproachingBottomCrossroadStraight)) {
                const intersectionY = isCarApproachingTopCrossroadTurn ? centerY - car.b : centerY + car.b;
                const intersectionX = centerX; // Intersection for vertical road is at centerX

                const distCarToIntersection = Math.hypot(car.x - intersectionX, car.y - intersectionY);
                const distOtherCarToIntersection = Math.hypot(otherCar.x - intersectionX, otherCar.y - intersectionY);

                const speedCar = car.maximumSpeed * 50 * car.currentSpeedFactor;
                const speedOtherCar = otherCar.maximumSpeed * 50 * otherCar.currentSpeedFactor;

                const timeToIntersectionCar = speedCar > 0.01 ? distCarToIntersection / speedCar : Infinity;
                const timeToIntersectionOtherCar = speedOtherCar > 0.01 ? distOtherCarToIntersection / speedOtherCar : Infinity;

                if (distCarToIntersection < CAR_LENGTH * CROSSROAD_SAFETY_DISTANCE &&
                    distOtherCarToIntersection < CAR_LENGTH * CROSSROAD_SAFETY_DISTANCE * 1.5 &&
                    timeToIntersectionOtherCar < timeToIntersectionCar * 1.2) {
                    collisionRiskDetected = true;
                }
            }
        }
    }

    // A car on the vertical road has to yield to cars on the ellipse when rejoining or entering.
    if (car.path === "vertical" && (car.turnState === "rejoining_top" || car.turnState === "rejoining_bottom" || car.turnState === "entering_ellipse")) {
      if (otherCar.path === "ellipse") {
        const intersectionPointX = centerX; // Vertical road is at centerX
        const intersectionPointY = (car.turnState === "rejoining_top" || car.turnState === "entering_ellipse") ? centerY - car.b : centerY + car.b;

        const distCarToIntersection = Math.hypot(car.x - intersectionPointX, car.y - intersectionPointY);
        const distOtherCarToIntersection = Math.hypot(otherCar.x - intersectionPointX, otherCar.y - intersectionPointY);

        const timeToIntersectionCar = distCarToIntersection / (car.maximumSpeed * 50 * car.currentSpeedFactor);
        const timeToIntersectionOtherCar = distOtherCarToIntersection / (otherCar.maximumSpeed * 50 * otherCar.currentSpeedFactor);

        if (distCarToIntersection < CAR_LENGTH * CROSSROAD_SAFETY_DISTANCE && distOtherCarToIntersection < CAR_LENGTH * CROSSROAD_SAFETY_DISTANCE * 1.5 && timeToIntersectionOtherCar < timeToIntersectionCar * 1.5) {
          collisionRiskDetected = true;
        }
      }
    }

    return { distance, isTooClose: collisionRiskDetected, isAhead, relativeVelocity };
  }



  function updateCarPhysics(car, speed) {
    car.steerAngle += (car.targetSteerAngle - car.steerAngle) * STEERING_SMOOTHING_FACTOR;
    const MAX_STEER_CLAMP = Math.PI / 3;
    car.steerAngle = Math.max(-MAX_STEER_CLAMP, Math.min(MAX_STEER_CLAMP, car.steerAngle));

    if (Math.abs(car.steerAngle) > 0.001) {
      const turnRadius = WHEELBASE / Math.tan(Math.abs(car.steerAngle));
      const currentVelocity = car.maximumSpeed * 50 * car.currentSpeedFactor;
      const centrifugalForce = (currentVelocity ** 2) / turnRadius;
      if (centrifugalForce > MAX_CENTRIFUGAL_FORCE) {
        const targetVelocity = Math.sqrt(MAX_CENTRIFUGAL_FORCE * turnRadius);
        car.currentSpeedFactor = Math.min(car.currentSpeedFactor, targetVelocity / (car.maximumSpeed * 50));
      }
    }

    if (Math.abs(car.steerAngle) > 0.001) {
      const deltaHeading = Math.tan(car.steerAngle) * speed / WHEELBASE;
      car.heading += deltaHeading;
      while (car.heading > Math.PI) car.heading -= 2 * Math.PI;
      while (car.heading < -Math.PI) car.heading += 2 * Math.PI;
    }

    car.rearX += Math.cos(car.heading) * speed;
    car.rearY += Math.sin(car.heading) * speed;

    car.frontX = car.rearX + Math.cos(car.heading) * WHEELBASE;
    car.frontY = car.rearY + Math.sin(car.heading) * WHEELBASE;

    car.x = car.rearX + Math.cos(car.heading) * WHEELBASE * 0.5;
    car.y = car.rearY + Math.sin(car.heading) * WHEELBASE * 0.5;

    if (car.path === "ellipse" && car.verticalDirection === null) {
      car.rejoinBuffer += speed;
    }

    const carName = car === car1 ? "Car1" : car === car2 ? "Car2" : car === car3 ? "Car3" : car === car4 ? "Car4" : car === car5 ? "Car5" : car === car6 ? "Car6" : "UnknownCar";
    const headingDeg = car.heading * 180 / Math.PI;
    const lastHeadingDeg = car.lastLoggedHeading * 180 / Math.PI;
    const distTraveled = Math.hypot(car.x - car.lastLoggedX, car.y - car.lastLoggedY);

    if (DEBUG_LOG && (Math.abs(headingDeg - lastHeadingDeg) > LOG_HEADING_THRESHOLD_DEG || distTraveled > LOG_DISTANCE_THRESHOLD_PX)) {
      const turnRadius = Math.abs(car.steerAngle) > 0.001 ? WHEELBASE / Math.tan(Math.abs(car.steerAngle)) : Number.MAX_VALUE;
      console.log(`${carName} | Pos:(${Math.round(car.x)}, ${Math.round(car.y)}) | Head:${Math.round(headingDeg)}° | Steer:${Math.round(car.steerAngle * 180 / Math.PI)}° | Path:${car.path} | VertDir:${car.verticalDirection || 'none'} | SpeedFactor:${car.currentSpeedFactor.toFixed(3)} | TurnRadius:${turnRadius.toFixed(1)} | CentrifugalForce:${((car.maximumSpeed * 50 * car.currentSpeedFactor) ** 2 / (turnRadius || car.b)).toFixed(6)} | Yielding:${car.isYielding}`);
      car.lastLoggedHeading = car.heading;
      car.lastLoggedX = car.x;
      car.lastLoggedY = car.y;
    }
  }

  function drawCar(car) {
    const carName = car === car1 ? "Car1" : car === car2 ? "Car2" : car === car3 ? "Car3" : car === car4 ? "Car4" : car === car5 ? "Car5" : car === car6 ? "Car6" : "UnknownCar";
    const carNumber = carName.replace('Car','');
    ctx.save();
    ctx.translate(car.x, car.y);
    ctx.rotate(car.heading);
    ctx.scale(CAR_SCALE, CAR_SCALE);
    const frameWidth = 518;
    const frameHeight = 465;

    if (spriteSheet.complete && spriteSheet.naturalWidth > 0) {
      ctx.drawImage(spriteSheet, 0, 0, frameWidth, frameHeight, -259, -91.5, frameWidth, frameHeight);
    } else {
      // Assign different colors for better visibility if sprite fails to load
      let fillColor;
      if (car === car1) fillColor = 'red';
      else if (car === car2) fillColor = 'green';
      else if (car === car3) fillColor = 'blue';
      else if (car === car4) fillColor = 'purple';
      else if (car === car5) fillColor = 'orange'; // Color for car5
	  else if (car === car6) fillColor = 'cyan'; // Color for car6
      else fillColor = 'black'; // Default fallback

      ctx.fillStyle = fillColor;
      ctx.fillRect(-259, -91.5, frameWidth, frameHeight);
    }
    
    // Draw the car number
    /*ctx.fillStyle = 'red';
    ctx.font = 'bold 160px sans-serif'; // The font size is large because it will be scaled down
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(carNumber, 0, 0); // Draw number at the rotated center (adjust Y offset if needed)*/


    let blinkerFrame = null;
    if (car.turnState === 'approaching' || car.turnState === 'turning' || car.turnState === 'rejoining') {
      if (car.nextTurnIsLeft) {
        blinkerFrame = { sx: 1 * frameWidth, sy: 1 * frameHeight };
      } else {
        blinkerFrame = { sx: 2 * frameWidth, sy: 1 * frameHeight };
      }

      const currentTime = performance.now();
      const cycleTime = currentTime % BLINKER_CYCLE_MS;
      const isBlinkerOn = cycleTime < BLINKER_ON_MS;

      if (blinkerFrame && isBlinkerOn && spriteSheet.complete && spriteSheet.naturalWidth > 0) {
        ctx.drawImage(
          spriteSheet,
          blinkerFrame.sx, blinkerFrame.sy, frameWidth, frameHeight,
          -259, -91.5, frameWidth, frameHeight
        );
      }

      if (DEBUG_LOG && blinkerFrame && (car.turnState === 'approaching' || car.turnState === 'turning' ||
          (car.turnState === 'rejoining' && (Math.abs(car.x - car.lastLoggedX) > 25 || Math.abs(car.y - car.lastLoggedY) > 25)))) {
        console.log(`${carName} displaying ${car.nextTurnIsLeft ? 'left' : 'right'} blinker: ${isBlinkerOn ? 'ON' : 'OFF'} at Pos:(${Math.round(car.x)}, ${Math.round(car.y)}), TurnState:${car.turnState}, NextTurnIsLeft:${car.nextTurnIsLeft}`);
        car.lastLoggedX = car.x;
        car.lastLoggedY = car.y;
      }
    }

    if (typeof car.lastSpeedFactor === 'undefined') {
      car.lastSpeedFactor = car.currentSpeedFactor;
    }

    const isDecelerating = car.currentSpeedFactor < car.lastSpeedFactor || car.isYielding;
    if (isDecelerating && spriteSheet.complete && spriteSheet.naturalWidth > 0) {
      const brakeFrame = { sx: 0, sy: 1 * frameHeight };
      ctx.drawImage(
        spriteSheet,
        brakeFrame.sx, brakeFrame.sy, frameWidth, frameHeight,
        -259, -91.5, frameWidth, frameHeight
      );

      if (DEBUG_LOG && (Math.abs(car.x - car.lastLoggedX) > 25 || Math.abs(car.y - car.lastLoggedY) > 25)) {
        console.log(`${carName} displaying brake lights at Pos:(${Math.round(car.x)}, ${Math.round(car.y)}), SpeedFactor:${car.currentSpeedFactor.toFixed(3)}, LastSpeedFactor:${car.lastSpeedFactor.toFixed(3)}, Yielding:${car.isYielding}`);
      }
    }
    car.lastSpeedFactor = car.currentSpeedFactor;
    ctx.restore();
  }

function updateCar(car) {
  const carName = car === car1 ? "Car1" : car === car2 ? "Car2" : car === car3 ? "Car3" : car === car4 ? "Car4" : car === car5 ? "Car5" : car === car6 ? "Car6" : "UnknownCar";
  let currentSpeed = car.maximumSpeed * 50 * car.currentSpeedFactor;
  let targetX, targetY;
  car.isYielding = false;

  const isAtIntersection = Math.abs(car.x - centerX) < ROAD_WIDTH * 0.9;
  const isApproachingTopCrossroad = car.y < centerY - car.b + ROAD_WIDTH * 3 && isAtIntersection && car.path === "ellipse" && car.canDecide;
  const isApproachingBottomCrossroad = car.y > centerY + car.b - ROAD_WIDTH * 3 && isAtIntersection && car.path === "ellipse" && car.canDecide;
  const isOnVerticalSegment = car.path === "vertical";
  let isRejoining = car.path === "ellipse" && car.verticalDirection !== null;

  const distToTop = Math.abs(car.y - (centerY - car.b));
  const distToBottom = Math.abs(car.y - (centerY + car.b));

  // Collision and priority checks
  const cars = [car1, car2, car3, car4, car5, car6].filter(c => c !== car);
  let minDistanceToOtherCar = Infinity;
  let closestCarAhead = null;
  let shouldYield = false;

  for (const otherCar of cars) {
    const { distance, isTooClose, isAhead, relativeVelocity } = checkCollisionRisk(car, otherCar);
    if (distance < minDistanceToOtherCar) {
      minDistanceToOtherCar = distance;
    }
    if (isAhead && distance < CAR_LENGTH * LOOK_AHEAD_CAR_LENGTHS * 1.5) { // Increased lookahead for finding the car
        if(!closestCarAhead || distance < getDistance(car, closestCarAhead)){
             closestCarAhead = otherCar;
        }
    }
    if (isOnVerticalSegment && (
        (car.verticalDirection === "down" && car.y > centerY + car.b - ROAD_WIDTH * 0.5) ||
        (car.verticalDirection === "up" && car.y < centerY - car.b + ROAD_WIDTH * 0.5)
      ) && otherCar.path === "ellipse" && isAhead) {
      shouldYield = true;
      car.isYielding = true;
      car.yieldStartTime = car.yieldStartTime || performance.now();
    }
  }

    // New intersection safety logic based on CROSSROAD_SAFETY_DISTANCE
    const safetyDistancePixels = CROSSROAD_SAFETY_DISTANCE * CAR_LENGTH;
    let turnIsUnsafe = false;

    // Rule D: Left turn from elliptical to vertical. This is made by Clockwise cars.
    const isApproachingTurnFromEllipse = (isApproachingTopCrossroad || isApproachingBottomCrossroad) && car.willTurn;
    if (isApproachingTurnFromEllipse && car.direction === -1) {
        const intersectionPoint = isApproachingTopCrossroad ? { x: centerX, y: centerY - car.b } : { x: centerX, y: centerY + car.b };
        for (const otherCar of cars) {
            // Per prompt, check for other clockwise cars.
            if (otherCar.path === "ellipse" && otherCar.direction === -1) {
                const distToIntersection = Math.hypot(otherCar.x - intersectionPoint.x, otherCar.y - intersectionPoint.y);
                if (distToIntersection < safetyDistancePixels) {
                    turnIsUnsafe = true;
                    break;
                }
            }
        }
    }

    // Rules A & B: Turning from vertical to ellipse
    const isApproachingRejoinFromVertical = car.path === "vertical" && (
        (car.verticalDirection === "up" && car.y < centerY - car.b + ROAD_WIDTH * 1.5) ||
        (car.verticalDirection === "down" && car.y > centerY + car.b - ROAD_WIDTH * 1.5)
    );
    if (isApproachingRejoinFromVertical) {
        if (car.verticalDirection === "up") { // Rule B: Left turn (rejoining CCW lane) at top
            const intersectionPoint = { x: centerX, y: centerY - car.b };
            for (const otherCar of cars) {
                if (otherCar.path === "ellipse") { // Check all ellipse cars
                    const distToIntersection = Math.hypot(otherCar.x - intersectionPoint.x, otherCar.y - intersectionPoint.y);
                    if (distToIntersection < safetyDistancePixels) {
                        turnIsUnsafe = true;
                        break;
                    }
                }
            }
        } else { // Rule A: Right turn (rejoining CW lane) at bottom
            const intersectionPoint = { x: centerX, y: centerY + car.b };
            for (const otherCar of cars) {
                if (otherCar.path === "ellipse" && otherCar.direction === -1) { // Check CW cars
                    const isApproachingFromLeft = otherCar.x < centerX;
                    const distToIntersection = Math.hypot(otherCar.x - intersectionPoint.x, otherCar.y - intersectionPoint.y);
                    // Check if car is within safety distance AND approaching from the left, OR if it's right AT the intersection
                    if ((isApproachingFromLeft && distToIntersection < safetyDistancePixels) || (distToIntersection < CAR_LENGTH / 2)) {
                        turnIsUnsafe = true;
                        break;
                    }
                }
            }
        }
    }

    if (turnIsUnsafe && car.path !== 'vertical') {
        shouldYield = true;
        car.isYielding = true;
        car.yieldStartTime = car.yieldStartTime || performance.now();
    }

  // Check for yield timeout to prevent deadlocks
  if (car.isYielding && performance.now() - car.yieldStartTime > YIELD_TIMEOUT) {
    car.isYielding = false;
    car.yieldStartTime = 0;
    car.currentSpeedFactor = Math.min(car.currentSpeedFactor + MAX_ACCELERATION * 0.5 / (car.maximumSpeed * 50), 1.0);
    if (DEBUG_LOG) console.log(`${carName} yield timeout, resuming at Pos:(${Math.round(car.x)}, ${Math.round(car.y)}), SpeedFactor:${car.currentSpeedFactor.toFixed(3)}`);
  }

  // Adjust speed for cars ahead on the same road
  if (closestCarAhead && !car.isYielding) {
    const reactionDistance = CAR_LENGTH * LOOK_AHEAD_CAR_LENGTHS;
    const stoppingDistance = CAR_LENGTH * (1.0 + 0.4); // 1 car length + 40% gap
    const distanceToAhead = getDistance(car, closestCarAhead);

    if (distanceToAhead < stoppingDistance) {
        // Hard stop to enforce the minimum gap
        car.currentSpeedFactor = 0;
    } else if (distanceToAhead < reactionDistance) {
        // Original smooth slowing logic
        if (car.path === "ellipse" && closestCarAhead.path === "vertical") {
            const isOtherRejoiningTop = closestCarAhead.verticalDirection === "up" && closestCarAhead.y < centerY - closestCarAhead.b + ROAD_WIDTH * 0.5;
            const isOtherRejoiningBottom = closestCarAhead.verticalDirection === "down" && closestCarAhead.y > centerY + closestCarAhead.b - ROAD_WIDTH * 0.5;
            if (isOtherRejoiningTop || isOtherRejoiningBottom) {
                const relativeVelocity = (car.maximumSpeed * 50 * car.currentSpeedFactor) - (closestCarAhead.maximumSpeed * 50 * closestCarAhead.currentSpeedFactor);
                if (relativeVelocity > 0) {
                    const targetSpeedFactor = Math.max(0, closestCarAhead.currentSpeedFactor - (reactionDistance - distanceToAhead) / reactionDistance * 0.5);
                    car.currentSpeedFactor += (targetSpeedFactor - car.currentSpeedFactor) * SPEED_SMOOTHING_FACTOR;
                }
            }
        } else {
            const relativeVelocity = (car.maximumSpeed * 50 * car.currentSpeedFactor) - (closestCarAhead.maximumSpeed * 50 * closestCarAhead.currentSpeedFactor);
            if (relativeVelocity > 0) {
                const targetSpeedFactor = Math.max(0, closestCarAhead.currentSpeedFactor - (reactionDistance - distanceToAhead) / reactionDistance * 0.5);
                car.currentSpeedFactor += (targetSpeedFactor - car.currentSpeedFactor) * SPEED_SMOOTHING_FACTOR;
            }
        }
    }
  }


  // Yielding logic for rejoining
  if (shouldYield) {
    car.currentSpeedFactor = 0;
    currentSpeed = 0;
    if (DEBUG_LOG) {
      console.log(`${carName} yielding to ellipse traffic at Pos:(${Math.round(car.x)}, ${Math.round(car.y)}), SpeedFactor:${car.currentSpeedFactor.toFixed(3)}`);
    }
    targetX = car.x;
    targetY = car.y;
  } else {
    // Normal turn decision logic
    if (isApproachingTopCrossroad && car.turnState === null) {
      car.willTurn = Math.random() < 0.5;
      if (car.willTurn) {
        car.nextTurnIsLeft = car.direction === -1 ? true : false;
        car.turnState = 'approaching';
        if (DEBUG_LOG) console.log(`${carName} at top crossroad: will turn ${car.nextTurnIsLeft ? 'left' : 'right'}, turnState: approaching`);
      }
      car.canDecide = false;
    } else if (isApproachingBottomCrossroad && car.turnState === null) {
      car.willTurn = Math.random() < 0.5;
      if (car.willTurn) {
        car.nextTurnIsLeft = car.direction === 1 ? false : true;
        car.turnState = 'approaching';
        if (DEBUG_LOG) console.log(`${carName} at bottom crossroad: will turn ${car.nextTurnIsLeft ? 'left' : 'right'}, turnState: approaching`);
      }
      car.canDecide = false;
    }

    // Anticipation logic for speed adjustment
    let targetSpeedFactor = car.currentSpeedFactor;
    let predictedTurnRadius = car.b;

    if (isApproachingTopCrossroad && car.willTurn) {
      predictedTurnRadius = ROAD_WIDTH / 2;
    } else if (isApproachingBottomCrossroad && car.willTurn) {
      predictedTurnRadius = ROAD_WIDTH / 2;
    } else if (isOnVerticalSegment) {
      if (car.verticalDirection === "down" && car.y > centerY + car.b - ROAD_WIDTH * 1.5) {
        car.nextTurnIsLeft = car.direction === 1 ? false : true;
        predictedTurnRadius = car.nextTurnIsLeft ? ROAD_WIDTH / 2 : car.b;
        if (car.turnState !== 'rejoining') {
          car.turnState = 'rejoining';
          if (DEBUG_LOG) console.log(`${carName} approaching rejoin from vertical downward, turnState: rejoining, turn: ${car.nextTurnIsLeft ? 'left' : 'right'}`);
        }
      } else if (car.verticalDirection === "up" && car.y < centerY - car.b + ROAD_WIDTH * 1.5) {
        car.nextTurnIsLeft = car.direction === -1 ? true : false;
        predictedTurnRadius = car.nextTurnIsLeft ? ROAD_WIDTH / 2 : car.b;
        if (car.turnState !== 'rejoining') {
          car.turnState = 'rejoining';
          if (DEBUG_LOG) console.log(`${carName} approaching rejoin from vertical upward, turnState: rejoining, turn: ${car.nextTurnIsLeft ? 'left' : 'right'}`);
        }
      } else {
        predictedTurnRadius = Number.MAX_VALUE;
      }
    } else if (isRejoining && Math.abs(car.steerAngle * 180 / Math.PI) > 10) {
      predictedTurnRadius = Math.abs(car.steerAngle) > 0.001 ? WHEELBASE / Math.tan(Math.abs(car.steerAngle)) : car.b;
    } else {
      const expectedAngle = Math.atan2(car.y - centerY, car.x - centerX);
      let headingError = Math.abs(car.heading - expectedAngle);
      while (headingError > Math.PI) headingError -= 2 * Math.PI;
      while (headingError < -Math.PI) headingError += 2 * Math.PI;
      const radialDistance = Math.hypot(car.x - centerX, (car.y - centerY) * car.a / car.b);
      const isOnEllipse = Math.abs(radialDistance - car.a) < ROAD_WIDTH * 1.5;
      if (isRejoining) {
        car.rejoinBuffer += currentSpeed;
        if ((Math.abs(headingError * 180 / Math.PI) < 30 && isOnEllipse) || car.rejoinBuffer > REJOIN_BUFFER_DISTANCE * 0.5) {
          car.verticalDirection = null;
          car.rejoinBuffer = 0;
          car.turnState = null;
          isRejoining = false;
          predictedTurnRadius = car.b;
          if (DEBUG_LOG) console.log(`${carName} rejoin complete, reset verticalDirection and turnState at Pos:(${Math.round(car.x)}, ${Math.round(car.y)})`);
        }
      }
    }

    const currentVelocity = car.maximumSpeed * 50 * car.currentSpeedFactor;
    const targetVelocity = Math.sqrt(predictedTurnRadius * MAX_CENTRIFUGAL_FORCE);
    const decelerationDistance = Math.abs(currentVelocity - targetVelocity) / MAX_ACCELERATION * 4;

    if ((isApproachingTopCrossroad && car.willTurn && distToTop <= decelerationDistance) ||
        (isApproachingBottomCrossroad && car.willTurn && distToBottom <= decelerationDistance) ||
        (isOnVerticalSegment && (car.y > centerY + car.b - ROAD_WIDTH * 1.5 || car.y < centerY - car.b + ROAD_WIDTH * 1.5)) ||
        (isRejoining && Math.abs(car.steerAngle * 180 / Math.PI) > 10)) {
      targetSpeedFactor = Math.min(1.0, targetVelocity / (car.maximumSpeed * 50));
      car.currentSpeedFactor += (targetSpeedFactor - car.currentSpeedFactor) * SPEED_SMOOTHING_FACTOR;
    } else if (car.currentSpeedFactor < 1.0 && Math.abs(car.steerAngle * 180 / Math.PI) < 10 && !isApproachingTopCrossroad && !isApproachingBottomCrossroad && !closestCarAhead) {
      targetSpeedFactor = Math.min(1.0, car.currentSpeedFactor + MAX_ACCELERATION * 0.5 / (car.maximumSpeed * 50));
      car.currentSpeedFactor += (targetSpeedFactor - car.currentSpeedFactor) * SPEED_SMOOTHING_FACTOR;
    }

    // New logic to handle stopping vertical cars at the intersection line
    if (turnIsUnsafe && car.path === 'vertical') {
        let distanceToStopLine;
        if (car.verticalDirection === 'up') {
            const stopLineY = centerY - car.b;
            const carFrontY = car.y - (CAR_LENGTH / 2);
            distanceToStopLine = carFrontY - stopLineY;
        } else { // 'down'
            const stopLineY = centerY + car.b;
            const carFrontY = car.y + (CAR_LENGTH / 2);
            distanceToStopLine = stopLineY - carFrontY;
        }

        const carIsAtStopLine = distanceToStopLine < 1.0;

        if (carIsAtStopLine) {
            car.currentSpeedFactor = 0;
            car.isYielding = true;
            if (car.verticalDirection === 'up') {
                car.y = (centerY - car.b) + (CAR_LENGTH / 2);
            } else {
                car.y = (centerY + car.b) - (CAR_LENGTH / 2);
            }
        } else {
            const reactionDistance = CAR_LENGTH * 4;
            if (distanceToStopLine < reactionDistance) {
                const targetSpeedFactor = Math.max(0, (distanceToStopLine / reactionDistance));
                 if (targetSpeedFactor < car.currentSpeedFactor) {
                    car.currentSpeedFactor = targetSpeedFactor;
                    car.isYielding = true;
                }
            }
        }
    }

    // Path and steering logic
    // Must re-calculate currentSpeed after potential changes to currentSpeedFactor
    currentSpeed = car.maximumSpeed * 50 * car.currentSpeedFactor;
    if (isApproachingTopCrossroad) {
      if (car.willTurn) {
        car.path = "vertical";
        car.verticalDirection = "down";
        car.turnState = 'turning';
        targetX = DOWNWARD_LANE_X;
        targetY = car.y + LOOK_AHEAD_DISTANCE;
        if (DEBUG_LOG) console.log(`${carName} at top crossroad: turning to vertical road (downward)`);
      } else {
        const lookAheadAngle = car.angle + car.direction * car.speed * 5;
        targetX = centerX + car.a * Math.cos(lookAheadAngle);
        targetY = centerY + car.b * Math.sin(lookAheadAngle);
        car.turnState = null;
      }
    } else if (isApproachingBottomCrossroad) {
      if (car.willTurn) {
        car.path = "vertical";
        car.verticalDirection = "up";
        car.turnState = 'turning';
        targetX = UPWARD_LANE_X;
        targetY = car.y - LOOK_AHEAD_DISTANCE;
        if (DEBUG_LOG) console.log(`${carName} at bottom crossroad: turning to vertical road (upward)`);
      } else {
        const lookAheadAngle = car.angle + car.direction * car.speed * 5;
        targetX = centerX + car.a * Math.cos(lookAheadAngle);
        targetY = centerY + car.b * Math.sin(lookAheadAngle);
        car.turnState = null;
      }
    } else if (isOnVerticalSegment) {
      let laneCenter = car.verticalDirection === "up" ? UPWARD_LANE_X : DOWNWARD_LANE_X;
      targetX = laneCenter;
      targetY = car.y + (car.verticalDirection === "down" ? LOOK_AHEAD_DISTANCE : -LOOK_AHEAD_DISTANCE);

      const headingError = Math.abs(car.heading - (car.verticalDirection === "up" ? -Math.PI / 2 : Math.PI / 2));
      if (headingError < Math.PI / 10 && Math.abs(car.x - laneCenter) < ROAD_WIDTH / 4 && car.turnState === 'turning') {
        car.turnState = null;
        car.willTurn = false;
        if (DEBUG_LOG) console.log(`${carName} turn complete, aligned with vertical road at Pos:(${Math.round(car.x)}, ${Math.round(car.y)})`);
      }

      if (car.verticalDirection === "down" && car.y > centerY + car.b - ROAD_WIDTH / 2 && !shouldYield) {
        car.path = "ellipse";
        car.angle = Math.atan2((car.y - centerY) / car.b, (car.x - centerX) / car.a);
        if (car.nextTurnIsLeft) {
          let targetAngleForLeftTurn = (car.direction === -1) ? Math.PI * 0.25 : Math.PI * 1.25;
          targetX = centerX + car.a * Math.cos(targetAngleForLeftTurn);
          targetY = centerY + car.b * Math.sin(targetAngleForLeftTurn);
          if (DEBUG_LOG) console.log(`${carName} rejoined from vertical downward: left turn`);
        } else {
          const lookAheadAngle = car.angle + car.direction * car.speed * 5;
          targetX = centerX + car.a * Math.cos(lookAheadAngle);
          targetY = centerY + car.b * Math.sin(lookAheadAngle);
          if (DEBUG_LOG) console.log(`${carName} rejoined from vertical downward: right turn`);
        }
      } else if (car.verticalDirection === "up" && car.y < centerY - car.b + ROAD_WIDTH / 2 && !shouldYield) {
        car.path = "ellipse";
        car.angle = Math.atan2((car.y - centerY) / car.b, (car.x - centerX) / car.a);
        if (car.nextTurnIsLeft) {
          let targetAngleForLeftTurn = (car.direction === -1) ? Math.PI * 1.75 : Math.PI * 0.75;
          targetX = centerX + car.a * Math.cos(targetAngleForLeftTurn);
          targetY = centerY + car.b * Math.sin(targetAngleForLeftTurn);
          if (DEBUG_LOG) console.log(`${carName} rejoined from vertical upward: left turn`);
        } else {
          const lookAheadAngle = car.angle + car.direction * car.speed * 5;
          targetX = centerX + car.a * Math.cos(lookAheadAngle);
          targetY = centerY + car.b * Math.sin(lookAheadAngle);
          if (DEBUG_LOG) console.log(`${carName} rejoined from vertical upward: right turn`);
        }
      }
    } else {
      car.path = "ellipse";
      if (!isRejoining) { // Only update angle if not in the middle of rejoining
        car.angle = Math.atan2((car.y - centerY) / car.b, (car.x - centerX) / car.a);
      }
      const lookAheadAngle = car.angle + car.direction * car.speed * 5;
      targetX = centerX + car.a * Math.cos(lookAheadAngle);
      targetY = centerY + car.b * Math.sin(lookAheadAngle);

      if (car.rejoinBuffer < REJOIN_BUFFER_DISTANCE) {
        targetX = centerX + car.a * Math.cos(lookAheadAngle);
        targetY = centerY + car.b * Math.sin(lookAheadAngle);
      }

      if (car.y > centerY - car.b + 2 * ROAD_WIDTH && car.y < centerY + car.b - 2 * ROAD_WIDTH) {
        car.canDecide = true;
      }
    }
  }

  const dx = targetX - car.x;
  const dy = targetY - car.y;
  let targetHeading = (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1) ? car.heading : Math.atan2(dy, dx);

  let headingError = targetHeading - car.heading;
  while (headingError > Math.PI) headingError -= 2 * Math.PI;
  while (headingError < -Math.PI) headingError += 2 * Math.PI;
  if (isNaN(headingError)) headingError = 0;

  let steeringBoost = 1.0;
  if (isOnVerticalSegment || isRejoining) {
    steeringBoost = 1.2;
  }

  car.targetSteerAngle = headingError * STEERING_GAIN * steeringBoost;
  car.targetSteerAngle = Math.max(-SYMMETRIC_MAX_TURN_STEER_ANGLE, Math.min(SYMMETRIC_MAX_TURN_STEER_ANGLE, car.targetSteerAngle));

  updateCarPhysics(car, currentSpeed);
  car.x = Math.max(0, Math.min(canvas.width, car.x));
  car.y = Math.max(0, Math.min(canvas.height, car.y));
}
  function resetSimulation() {
    // Reset car1 (CW)
    car1.angle = 0; // Right side
    car1.heading = Math.PI / 2; // Pointing up
    car1.maximumSpeed = 0.05;
    car1.speed = 0.05;
    car1.currentSpeedFactor = 1.0;
    car1.steerAngle = 0;
    car1.targetSteerAngle = 0;
    car1.path = "ellipse";
    car1.verticalDirection = null;
    car1.direction = -1;
    car1.nextTurnIsLeft = false;
    car1.rejoinBuffer = 0;
    car1.turnState = null;
    car1.willTurn = false;
    car1.canDecide = true;
    car1.isYielding = false;
    car1.yieldStartTime = 0;
    car1.x = centerX + car1.a * Math.cos(car1.angle);
    car1.y = centerY + car1.b * Math.sin(car1.angle);
    car1.rearX = car1.x - Math.cos(car1.heading) * WHEELBASE * 0.5;
    car1.rearY = car1.y - Math.sin(car1.heading) * WHEELBASE * 0.5;
    car1.frontX = car1.rearX + Math.cos(car1.heading) * WHEELBASE;
    car1.frontY = car1.rearY + Math.sin(car1.heading) * WHEELBASE;
    car1.lastLoggedHeading = car1.heading;
    car1.lastLoggedX = car1.x;
    car1.lastLoggedY = car1.y;

    // Reset car2 (CCW)
    car2.angle = Math.PI * 5 / 4; // Top-left quadrant
    car2.heading = car2.angle - Math.PI / 2; // Pointing down-left
    car2.maximumSpeed = 0.05;
    car2.speed = 0.05;
    car2.currentSpeedFactor = 1.0;
    car2.steerAngle = 0;
    car2.targetSteerAngle = 0;
    car2.path = "ellipse";
    car2.verticalDirection = null;
    car2.direction = 1;
    car2.nextTurnIsLeft = false;
    car2.rejoinBuffer = 0;
    car2.turnState = null;
    car2.willTurn = false;
    car2.canDecide = true;
    car2.isYielding = false;
    car2.yieldStartTime = 0;
    car2.x = centerX + car2.a * Math.cos(car2.angle);
    car2.y = centerY + car2.b * Math.sin(car2.angle);
    car2.rearX = car2.x - Math.cos(car2.heading) * WHEELBASE * 0.5;
    car2.rearY = car2.y - Math.sin(car2.heading) * WHEELBASE * 0.5;
    car2.frontX = car2.rearX + Math.cos(car2.heading) * WHEELBASE;
    car2.frontY = car2.rearY + Math.sin(car2.heading) * WHEELBASE;
    car2.lastLoggedHeading = car2.heading;
    car2.lastLoggedX = car2.x;
    car2.lastLoggedY = car2.y;

    // Reset car3 (CW)
    car3.angle = Math.PI; // Left side
    car3.heading = Math.PI * 3 / 2; // Pointing down
    car3.maximumSpeed = 0.05;
    car3.speed = 0.05;
    car3.currentSpeedFactor = 1.0;
    car3.steerAngle = 0;
    car3.targetSteerAngle = 0;
    car3.path = "ellipse";
    car3.verticalDirection = null;
    car3.direction = -1;
    car3.nextTurnIsLeft = false;
    car3.rejoinBuffer = 0;
    car3.turnState = null;
    car3.willTurn = false;
    car3.canDecide = true;
    car3.isYielding = false;
    car3.yieldStartTime = 0;
    car3.x = centerX + car3.a * Math.cos(car3.angle);
    car3.y = centerY + car3.b * Math.sin(car3.angle);
    car3.rearX = car3.x - Math.cos(car3.heading) * WHEELBASE * 0.5;
    car3.rearY = car3.y - Math.sin(car3.heading) * WHEELBASE * 0.5;
    car3.frontX = car3.rearX + Math.cos(car3.heading) * WHEELBASE;
    car3.frontY = car3.rearY + Math.sin(car3.heading) * WHEELBASE;
    car3.lastLoggedHeading = car3.heading;
    car3.lastLoggedX = car3.x;
    car3.lastLoggedY = car3.y;

    // Reset car4 (CCW)
    car4.angle = Math.PI / 4; // Bottom-right quadrant
    car4.heading = car4.angle - Math.PI / 2; // Pointing up-right
    car4.maximumSpeed = 0.05;
    car4.speed = 0.05;
    car4.currentSpeedFactor = 1.0;
    car4.steerAngle = 0;
    car4.targetSteerAngle = 0;
    car4.path = "ellipse";
    car4.verticalDirection = null;
    car4.direction = 1;
    car4.nextTurnIsLeft = false;
    car4.rejoinBuffer = 0;
    car4.turnState = null;
    car4.willTurn = false;
    car4.canDecide = true;
    car4.isYielding = false;
    car4.x = centerX + car4.a * Math.cos(car4.angle);
    car4.y = centerY + car4.b * Math.sin(car4.angle);
    car4.rearX = car4.x - Math.cos(car4.heading) * WHEELBASE * 0.5;
    car4.rearY = car4.y - Math.sin(car4.heading) * WHEELBASE * 0.5;
    car4.frontX = car4.rearX + Math.cos(car4.heading) * WHEELBASE;
    car4.frontY = car4.rearY + Math.sin(car4.heading) * WHEELBASE;
    car4.lastLoggedHeading = car4.heading;
    car4.lastLoggedX = car4.x;
    car4.lastLoggedY = car4.y;

    // Reset car5 (CW)
    car5.angle = -Math.PI / 2; // Top
    car5.heading = 0; // Pointing right
    car5.maximumSpeed = 0.05;
    car5.speed = 0.05;
    car5.currentSpeedFactor = 1.0;
    car5.steerAngle = 0;
    car5.targetSteerAngle = 0;
    car5.path = "ellipse";
    car5.verticalDirection = null;
    car5.direction = -1;
    car5.nextTurnIsLeft = false;
    car5.rejoinBuffer = 0;
    car5.turnState = null;
    car5.willTurn = false;
    car5.canDecide = true;
    car5.isYielding = false;
    car5.yieldStartTime = 0;
    car5.x = centerX + car5.a * Math.cos(car5.angle);
    car5.y = centerY + car5.b * Math.sin(car5.angle);
    car5.rearX = car5.x - Math.cos(car5.heading) * WHEELBASE * 0.5;
    car5.rearY = car5.y - Math.sin(car5.heading) * WHEELBASE * 0.5;
    car5.frontX = car5.rearX + Math.cos(car5.heading) * WHEELBASE;
    car5.frontY = car5.rearY + Math.sin(car5.heading) * WHEELBASE;
    car5.lastLoggedHeading = car5.heading;
    car5.lastLoggedX = car5.x;
    car5.lastLoggedY = car5.y;

  // Reset car6 (CW)
  car6.angle = Math.PI / 2; // Bottom
  car6.heading = Math.PI; // Pointing left
  car6.maximumSpeed = 0.05;
  car6.speed = 0.05;
  car6.currentSpeedFactor = 1.0;
  car6.steerAngle = 0;
  car6.targetSteerAngle = 0;
  car6.path = "ellipse";
  car6.verticalDirection = null;
  car6.direction = -1; // Clockwise
  car6.nextTurnIsLeft = false;
  car6.rejoinBuffer = 0;
  car6.turnState = null;
  car6.willTurn = false;
  car6.canDecide = true;
  car6.isYielding = false;
  car6.yieldStartTime = 0;
  car6.x = centerX + car6.a * Math.cos(car6.angle);
  car6.y = centerY + car6.b * Math.sin(car6.angle);
  car6.rearX = car6.x - Math.cos(car6.heading) * WHEELBASE * 0.5;
  car6.rearY = car6.y - Math.sin(car6.heading) * WHEELBASE * 0.5;
  car6.frontX = car6.rearX + Math.cos(car6.heading) * WHEELBASE;
  car6.frontY = car6.rearY + Math.sin(car6.heading) * WHEELBASE;
  car6.lastLoggedHeading = car6.heading;
  car6.lastLoggedX = car6.x;
  car6.lastLoggedY = car6.y;

    if (DEBUG_LOG) {
      console.clear();
      console.log("--- Simulation Reset ---");
    }

    // Ensure simulation resumes after reset if it was paused or if it's the initial load
    if (!isSimulationRunning) {
      const button = document.getElementById('toggleSimulationButton');
      if (button) button.textContent = 'Stop Simulation'; // Reset button text
      isSimulationRunning = true;
    }
    // Restart animation frame if it was paused or not yet started
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
    }
    animationFrameId = requestAnimationFrame(draw);
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBackground();
    drawRoad();
    drawDashedEllipse(centerX, centerY, 560, 360);
    drawDashedLine(centerX, 90, centerX, 810);
    drawCar(car1);
    drawCar(car2);
    drawCar(car3);
	drawCar(car4);
    drawCar(car5);
	drawCar(car6);
    update();
    if (isSimulationRunning) {
      animationFrameId = requestAnimationFrame(draw);
    }
  }

  function update() {
    updateCar(car1);
    updateCar(car2);
    updateCar(car3);
	updateCar(car4);
    updateCar(car5); // Update car5
	updateCar(car6);
  }

  function toggleSimulation() {
    const button = document.getElementById('toggleSimulationButton');
    if (isSimulationRunning) {
      cancelAnimationFrame(animationFrameId);
      isSimulationRunning = false;
      button.textContent = 'Resume Simulation';
      if (DEBUG_LOG) console.log("--- Simulation Paused ---");
    } else {
      animationFrameId = requestAnimationFrame(draw);
      isSimulationRunning = true;
      button.textContent = 'Stop Simulation';
      if (DEBUG_LOG) console.log("--- Simulation Resumed ---");
    }
  }

  spriteSheet.onload = () => {
    resetSimulation();
    // No need to explicitly call requestAnimationFrame here, resetSimulation already does it
  };
  spriteSheet.onerror = () => {
    console.error('Sprite failed to load, using fallback rectangles.');
    resetSimulation();
  };
</script>
</body>
</html>
