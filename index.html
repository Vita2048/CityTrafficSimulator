<!DOCTYPE html>
<html>
<head>
  <title>Traffic Simulation</title>
  <style>
    body {
      background-color: #f0f0f0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      margin: 0;
      padding: 20px;
      font-family: sans-serif;
    }
    canvas {
      border: 1px solid black;
      display: block;
      margin: 0 auto;
      background-color: white;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    button {
      display: block;
      margin: 20px auto;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      border: none;
      background-color: #4CAF50;
      color: white;
      border-radius: 5px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      transition: background-color 0.3s;
    }
    button:hover {
        background-color: #45a049;
    }
  </style>
</head>
<body>
  <canvas id="trafficCanvas" width="1200" height="800"></canvas>
  <button onclick="resetSimulation()">Reset Simulation</button>

  <script>
    const canvas = document.getElementById('trafficCanvas');
    const ctx = canvas.getContext('2d');
    const ROAD_WIDTH = 80; // Road width
    const CAR_SCALE = 0.1; // Scaling factor for car sprite
    const CAR_LENGTH = 518 * CAR_SCALE; // Car sprite width (518px) scaled

    // Car physics constants
    const WHEELBASE = (409 - 94) * CAR_SCALE; // Distance between rear and front axles

    // Center of the canvas
    const centerX = 600;
    const centerY = 400;

    // --- Unified steering and path-following constants ---
    const STEERING_GAIN = 0.8; // Proportional gain for steering correction.
    const LOOK_AHEAD_DISTANCE = 90; // Look-ahead distance for calculating the target point.
    const SYMMETRIC_MAX_TURN_STEER_ANGLE = Math.PI / 6; // Approx 30 degrees
    const UPWARD_LANE_X = centerX + ROAD_WIDTH / 4;   // Right lane for traffic going up
    const DOWNWARD_LANE_X = centerX - ROAD_WIDTH / 4; // Left lane for traffic going down

    // --- DEBUG LOGGING: Thresholds to prevent log clutter ---
    const LOG_HEADING_THRESHOLD_DEG = 5; // Log if heading changes by this many degrees.
    const LOG_DISTANCE_THRESHOLD_PX = 25; // Log if car travels this many pixels.

    // First car (right/outer lane, clockwise)
    let car1 = {
      angle: 0,
      a: 400 + ROAD_WIDTH / 4, 
      b: 200 + ROAD_WIDTH / 4, 
      speed: 0.035, // Clockwise, changed to positive for physics update
      x: 0, y: 0,
      rearX: 0, rearY: 0, frontX: 0, frontY: 0,
      heading: 0, // Will be initialized in resetSimulation
      steerAngle: 0,
      targetSteerAngle: 0,
      lastLoggedHeading: 0,
      lastLoggedX: 0, lastLoggedY: 0,
      path: "ellipse",
      canDecideAtTop: true,
      canDecideAtBottom: true,
      verticalDirection: null
    };

// Initialize car2 with path state and decision flags
let car2 = {
  angle: Math.PI, // Start opposite car1
  a: 400 - ROAD_WIDTH / 4, 
  b: 200 - ROAD_WIDTH / 4, 
  speed: 0.035,
  x: 0, y: 0,
  rearX: 0, rearY: 0, frontX: 0, frontY: 0,
  heading: -Math.PI / 2, 
  steerAngle: 0, targetSteerAngle: 0,
  lastLoggedHeading: -Math.PI / 2,
  lastLoggedX: 0, lastLoggedY: 0,
  path: "ellipse", // Track path: "ellipse" or "vertical"
  canDecideAtTop: true, // Allow decision at top crossroad
  canDecideAtBottom: true, // Allow decision at bottom crossroad
  verticalDirection: null // Track direction: "up" or "down" when on vertical path
};
    const spriteSheet = new Image();
    spriteSheet.src = 'https://vita2048.github.io/CityTrafficSimulator/CarSpritesheetLights.png';

    function drawBackground() {
      ctx.fillStyle = 'rgb(20, 140, 20)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawRoad() {
      ctx.strokeStyle = '#666';
      ctx.fillStyle = '#666';
      ctx.lineWidth = ROAD_WIDTH;
      ctx.beginPath();
      ctx.ellipse(centerX, centerY, 400, 200, 0, 0, Math.PI * 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(centerX, 200);
      ctx.lineTo(centerX, 600);
      ctx.stroke();
    }

    function drawDashedEllipse(x, y, a, b) {
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 2;
      ctx.setLineDash([15, 15]);
      ctx.beginPath();
      ctx.ellipse(x, y, a, b, 0, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function drawDashedLine(x1, y1, x2, y2) {
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 2;
      ctx.setLineDash([15, 15]);
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function updateCarPhysics(car, speed) {
      car.steerAngle += (car.targetSteerAngle - car.steerAngle) * 0.1; 
      
      const MAX_STEER_CLAMP = Math.PI / 3; 
      car.steerAngle = Math.max(-MAX_STEER_CLAMP, Math.min(MAX_STEER_CLAMP, car.steerAngle));

      if (Math.abs(car.steerAngle) > 0.001) {
        const deltaHeading = Math.tan(car.steerAngle) * speed / WHEELBASE;
        car.heading += deltaHeading;
        while (car.heading > Math.PI) car.heading -= 2 * Math.PI;
        while (car.heading < -Math.PI) car.heading += 2 * Math.PI;
      }
      
      car.rearX += Math.cos(car.heading) * speed;
      car.rearY += Math.sin(car.heading) * speed;
      
      car.frontX = car.rearX + Math.cos(car.heading) * WHEELBASE;
      car.frontY = car.rearY + Math.sin(car.heading) * WHEELBASE;
      
      car.x = car.rearX + Math.cos(car.heading) * WHEELBASE * 0.5;
      car.y = car.rearY + Math.sin(car.heading) * WHEELBASE * 0.5;

      // Debug logging for car1 and car2
      const carName = car === car1 ? "Car1" : "Car2";
      const headingDeg = car.heading * 180 / Math.PI;
      const lastHeadingDeg = car.lastLoggedHeading * 180 / Math.PI;
      const distTraveled = Math.hypot(car.x - car.lastLoggedX, car.y - car.lastLoggedY);

      if (Math.abs(headingDeg - lastHeadingDeg) > LOG_HEADING_THRESHOLD_DEG || distTraveled > LOG_DISTANCE_THRESHOLD_PX) {
          console.log(`${carName} | Pos:(${Math.round(car.x)}, ${Math.round(car.y)}) | Head:${Math.round(headingDeg)}° | Steer:${Math.round(car.steerAngle * 180 / Math.PI)}° | Path:${car.path} | VertDir:${car.verticalDirection}`);
          car.lastLoggedHeading = car.heading;
          car.lastLoggedX = car.x;
          car.lastLoggedY = car.y;
      }
    }

    function drawCar(car) {
      ctx.save();
      ctx.translate(car.x, car.y);

      let rotation = car.heading;
      // Car sprite faces right by default, add PI for counter-clockwise
      // car1 moves clockwise, so its heading should match the visual direction more directly
      // car2 moves counter-clockwise, it needs the PI offset
      ctx.rotate(rotation); 
      
      ctx.scale(CAR_SCALE, CAR_SCALE);

      const frameWidth = 518;
      const frameHeight = 465;
      if (spriteSheet.complete && spriteSheet.naturalWidth > 0) {
        ctx.drawImage(spriteSheet, 0, 0, frameWidth, frameHeight, -259, -91.5, frameWidth, frameHeight);
      } else {
        ctx.fillStyle = 'red';
        ctx.fillRect(-259, -91.5, frameWidth, frameHeight); 
      }
      ctx.restore();
    }

// Updated update function
function update() {
  // --- Update Car1 ---
  let currentSpeed1 = car1.speed * 50;
  let targetX1, targetY1;

  const isApproachingTopCrossroad1 = car1.y < centerY - car1.b + ROAD_WIDTH && car1.x > centerX - ROAD_WIDTH && car1.heading < Math.PI / 2 && car1.heading > -Math.PI/2 && car1.path === "ellipse" && car1.canDecideAtTop;
  const isApproachingBottomCrossroad1 = car1.y > centerY + car1.b - ROAD_WIDTH / 8 && car1.path === "ellipse" && car1.canDecideAtBottom && car1.heading < Math.PI / 4 && car1.heading > -Math.PI / 4;
  const isOnVerticalSegment1 = car1.path === "vertical";

  if (isApproachingTopCrossroad1) {
    car1.canDecideAtTop = false;
    if (Math.random() < 0.5) {
      car1.path = "vertical";
      car1.verticalDirection = "down"; // Clockwise from top to bottom
      targetX1 = UPWARD_LANE_X; // Right lane for car1's direction
      targetY1 = car1.y + LOOK_AHEAD_DISTANCE;
      console.log("Car1 at top crossroad: decided to take the vertical road (downward)");
    } else {
      const currentEllipseX_norm = (car1.x - centerX) / car1.a;
      const currentEllipseY_norm = (car1.y - centerY) / car1.b;
      car1.angle = Math.atan2(currentEllipseY_norm, currentEllipseX_norm);
      const lookAheadAngle = car1.angle - car1.speed * 5; // Clockwise
      targetX1 = centerX + car1.a * Math.cos(lookAheadAngle);
      targetY1 = centerY + car1.b * Math.sin(lookAheadAngle);
      console.log("Car1 at top crossroad: decided to continue on the ellipse");
    }
  } else if (isApproachingBottomCrossroad1) {
    car1.canDecideAtBottom = false;
    if (Math.random() < 0.5) {
      car1.path = "vertical";
      car1.verticalDirection = "up"; // Clockwise from bottom to top
      targetX1 = DOWNWARD_LANE_X; // Left lane for car1's direction
      targetY1 = car1.y - LOOK_AHEAD_DISTANCE;
      console.log("Car1 at bottom crossroad: decided to take the vertical road (upward)");
    } else {
      const currentEllipseX_norm = (car1.x - centerX) / car1.a;
      const currentEllipseY_norm = (car1.y - centerY) / car1.b;
      car1.angle = Math.atan2(currentEllipseY_norm, currentEllipseX_norm);
      const lookAheadAngle = car1.angle - car1.speed * 5; // Clockwise
      targetX1 = centerX + car1.a * Math.cos(lookAheadAngle);
      targetY1 = centerY + car1.b * Math.sin(lookAheadAngle);
      console.log("Car1 at bottom crossroad: decided to continue on the ellipse");
    }
    car1.canDecideAtTop = true; // Reset for next cycle
  } else if (isOnVerticalSegment1) {
    let laneCenter = car1.verticalDirection === "down" ? UPWARD_LANE_X : DOWNWARD_LANE_X;
    targetX1 = laneCenter + Math.max(-ROAD_WIDTH / 4, Math.min(ROAD_WIDTH / 4, (laneCenter - car1.x) * 0.7));
    targetY1 = car1.y + (car1.verticalDirection === "down" ? LOOK_AHEAD_DISTANCE : -LOOK_AHEAD_DISTANCE);

    // Always rejoin ellipse from vertical
    if (car1.verticalDirection === "down" && car1.y > centerY + car1.b - ROAD_WIDTH / 2) {
        car1.path = "ellipse";
        car1.verticalDirection = null;
        car1.canDecideAtTop = true; // Allow decision on next ellipse cycle
        car1.canDecideAtBottom = false; // Prevent immediate re-decision
        const currentEllipseX_norm = (car1.x - centerX) / car1.a;
        const currentEllipseY_norm = (car1.y - centerY) / car1.b;
        car1.angle = Math.atan2(currentEllipseY_norm, currentEllipseX_norm);
        const lookAheadAngle = car1.angle - car1.speed * 5; // Clockwise
        targetX1 = centerX + car1.a * Math.cos(lookAheadAngle);
        targetY1 = centerY + car1.b * Math.sin(lookAheadAngle);
        console.log("Car1 rejoined the ellipse from vertical road (downward)");
    } else if (car1.verticalDirection === "up" && car1.y < centerY - car1.b + ROAD_WIDTH / 2) {
        car1.path = "ellipse";
        car1.verticalDirection = null;
        car1.canDecideAtTop = false; // Prevent immediate re-decision
        car1.canDecideAtBottom = true; // Allow decision on next ellipse cycle
        const currentEllipseX_norm = (car1.x - centerX) / car1.a;
        const currentEllipseY_norm = (car1.y - centerY) / car1.b;
        car1.angle = Math.atan2(currentEllipseY_norm, currentEllipseX_norm);
        const lookAheadAngle = car1.angle - car1.speed * 5; // Clockwise
        targetX1 = centerX + car1.a * Math.cos(lookAheadAngle);
        targetY1 = centerY + car1.b * Math.sin(lookAheadAngle);
        console.log("Car1 rejoined the ellipse from vertical road (upward)");
    }
  } else {
    car1.path = "ellipse";
    const currentEllipseX_norm = (car1.x - centerX) / car1.a;
    const currentEllipseY_norm = (car1.y - centerY) / car1.b;
    car1.angle = Math.atan2(currentEllipseY_norm, currentEllipseX_norm);
    const lookAheadAngle = car1.angle - car1.speed * 5; // Clockwise
    targetX1 = centerX + car1.a * Math.cos(lookAheadAngle);
    targetY1 = centerY + car1.b * Math.sin(lookAheadAngle);
    // Reset decision flags when away from crossroads
    if (car1.y > centerY - car1.b + 2 * ROAD_WIDTH && car1.y < centerY + car1.b - 2 * ROAD_WIDTH) {
      car1.canDecideAtTop = true;
      car1.canDecideAtBottom = true;
    }
  }

  // Unified steering controller for car1
  const dx1 = targetX1 - car1.x;
  const dy1 = targetY1 - car1.y;
  let targetHeading1;
  if (Math.abs(dx1) < 0.1 && Math.abs(dy1) < 0.1) {
    targetHeading1 = car1.heading; 
  } else {
    targetHeading1 = Math.atan2(dy1, dx1);
  }

  let headingError1 = targetHeading1 - car1.heading;
  while (headingError1 > Math.PI) headingError1 -= 2 * Math.PI;
  while (headingError1 < -Math.PI) headingError1 += 2 * Math.PI;

  if (isNaN(headingError1) || isNaN(targetHeading1) || isNaN(car1.heading)) {
    console.log("Car1 NaN detected: targetHeading=", targetHeading1, "dx=", dx1, "dy=", dy1, "car1.heading=", car1.heading, "path=", car1.path);
  }
  
  const isRejoining1 = (car1.path === "ellipse" && 
                      ((car1.y > centerY + car1.b - ROAD_WIDTH && car1.y < centerY + car1.b + ROAD_WIDTH) ||
                       (car1.y < centerY - car1.b + ROAD_WIDTH && car1.y > centerY - car1.b - ROAD_WIDTH)));
  const laneCenterForTransition1 = car1.verticalDirection === "down" ? UPWARD_LANE_X : DOWNWARD_LANE_X;
  const isTransitioningToVertical1 = (car1.path === "vertical" && ((car1.verticalDirection === "down" && car1.y < centerY - car1.b + ROAD_WIDTH) || (car1.verticalDirection === "up" && car1.y > centerY + car1.b - ROAD_WIDTH)) && Math.abs(car1.x - laneCenterForTransition1) > 2);

  car1.targetSteerAngle = headingError1 * STEERING_GAIN * ((car1.path === "vertical" && (car1.verticalDirection === "up" || car1.verticalDirection === "down")) || isTransitioningToVertical1 ? 2.5 : isRejoining1 ? 2.0 : 1);
  car1.targetSteerAngle = isNaN(car1.targetSteerAngle) ? 0 : Math.max(-SYMMETRIC_MAX_TURN_STEER_ANGLE, Math.min(SYMMETRIC_MAX_TURN_STEER_ANGLE, car1.targetSteerAngle));

  updateCarPhysics(car1, currentSpeed1);
  car1.x = Math.max(0, Math.min(canvas.width, car1.x));
  car1.y = Math.max(0, Math.min(canvas.height, car1.y));


  // --- Update Car2 (unchanged from original logic) ---
  let currentSpeed2 = car2.speed * 50;
  let targetX2, targetY2;

  // Define crossroad conditions
  const isApproachingTopCrossroad2 = car2.y < centerY - car2.b + ROAD_WIDTH && car2.x > centerX - ROAD_WIDTH && car2.heading > -Math.PI / 2 && car2.path === "ellipse" && car2.canDecideAtTop;
  const isApproachingBottomCrossroad2 = car2.y > centerY + car2.b - ROAD_WIDTH / 8 && car2.path === "ellipse" && car2.canDecideAtBottom && car2.heading > 3 * Math.PI / 4;
  const isOnVerticalSegment2 = car2.path === "vertical";

  if (isApproachingTopCrossroad2) {
    // Make decision at top crossroad
    car2.canDecideAtTop = false;
    if (Math.random() < 0.5) {
      // Turn onto vertical road (downward)
      car2.path = "vertical";
      car2.verticalDirection = "down";
      targetX2 = DOWNWARD_LANE_X;
      targetY2 = car2.y + LOOK_AHEAD_DISTANCE;
      car2.speed = 0.035;
      console.log("Car2 at top crossroad: decided to take the vertical road (downward)");
    } else {
      // Continue on ellipse
      car2.path = "ellipse";
      const currentEllipseX_norm = (car2.x - centerX) / car2.a;
      const currentEllipseY_norm = (car2.y - centerY) / car2.b;
      car2.angle = Math.atan2(currentEllipseY_norm, currentEllipseX_norm);
      const lookAheadAngle = car2.angle + car2.speed * 5;
      targetX2 = centerX + car2.a * Math.cos(lookAheadAngle);
      targetY2 = centerY + car2.b * Math.sin(lookAheadAngle);
      car2.speed = 0.035;
      console.log("Car2 at top crossroad: decided to continue on the ellipse");
    }
  } else if (isApproachingBottomCrossroad2) {
    // Make decision at bottom crossroad (only from ellipse)
    car2.canDecideAtBottom = false;
    if (Math.random() < 0.5) {
      // Turn onto vertical road (upward)
      car2.path = "vertical";
      car2.verticalDirection = "up";
      targetX2 = UPWARD_LANE_X;
      targetY2 = car2.y - LOOK_AHEAD_DISTANCE;
      car2.speed = 0.035;
      console.log("Car2 at bottom crossroad: decided to take the vertical road (upward)");
    } else {
      // Continue on ellipse
      car2.path = "ellipse";
      const currentEllipseX_norm = (car2.x - centerX) / car2.a;
      const currentEllipseY_norm = (car2.y - centerY) / car2.b;
      car2.angle = Math.atan2(currentEllipseY_norm, currentEllipseX_norm);
      const lookAheadAngle = car2.angle + car2.speed * 5;
      targetX2 = centerX + car2.a * Math.cos(lookAheadAngle);
      targetY2 = centerY + car2.b * Math.sin(lookAheadAngle);
      car2.speed = 0.035;
      console.log("Car2 at bottom crossroad: decided to continue on the ellipse");
    }
    car2.canDecideAtTop = true;
  } else if (isOnVerticalSegment2) {
    // Follow vertical road by selecting the correct lane center
    let laneCenter = car2.verticalDirection === "up" ? UPWARD_LANE_X : DOWNWARD_LANE_X;
    targetX2 = laneCenter + Math.max(-ROAD_WIDTH / 4, Math.min(ROAD_WIDTH / 4, (laneCenter - car2.x) * 0.7));
    targetY2 = car2.y + (car2.verticalDirection === "down" ? LOOK_AHEAD_DISTANCE : -LOOK_AHEAD_DISTANCE);
    car2.speed = 0.035;

    // Check if car is approaching the end of the vertical segment for rejoin
    if (car2.verticalDirection === "down" && car2.y > centerY + car2.b - ROAD_WIDTH / 2) {
        // Start rejoining ellipse with right turn (counterclockwise)
        car2.path = "ellipse";
        car2.verticalDirection = null;
        car2.canDecideAtTop = true;
        car2.canDecideAtBottom = false;
        const targetAngle = Math.PI + car2.speed * 5;
        targetX2 = centerX + car2.a * Math.cos(targetAngle);
        targetY2 = centerY + car2.b * Math.sin(targetAngle);
        car2.angle = targetAngle;
        console.log("Car2 rejoined the ellipse from vertical road (downward, right turn)");
    } else if (car2.verticalDirection === "up" && car2.y < centerY - car2.b + ROAD_WIDTH / 2) {
        // Start rejoining ellipse with right turn (clockwise)
        car2.path = "ellipse";
        car2.verticalDirection = null;
        car2.canDecideAtTop = false;
        car2.canDecideAtBottom = true;
        const targetAngle = 0 - car2.speed * 5;
        targetX2 = centerX + car2.a * Math.cos(targetAngle);
        targetY2 = centerY + car2.b * Math.sin(targetAngle);
        car2.angle = targetAngle;
        console.log("Car2 rejoined the ellipse from vertical road (upward, right turn)");
    }
} else {
    // Follow ellipse
    car2.path = "ellipse";
    const currentEllipseX_norm = (car2.x - centerX) / car2.a;
    const currentEllipseY_norm = (car2.y - centerY) / car2.b;
    car2.angle = Math.atan2(currentEllipseY_norm, currentEllipseX_norm);
    const lookAheadAngle = car2.angle + car2.speed * 5;
    targetX2 = centerX + car2.a * Math.cos(lookAheadAngle);
    targetY2 = centerY + car2.b * Math.sin(lookAheadAngle);
    car2.speed = 0.035;
    // Reset decision flags when away from crossroads
    if (car2.y > centerY - car2.b + 2 * ROAD_WIDTH && car2.y < centerY + car2.b - 2 * ROAD_WIDTH) {
      car2.canDecideAtTop = true;
      car2.canDecideAtBottom = true;
    }
  }

// Unified steering controller for car2
  const dx2 = targetX2 - car2.x;
  const dy2 = targetY2 - car2.y;
  let targetHeading2;
  if (Math.abs(dx2) < 0.1 && Math.abs(dy2) < 0.1) {
    targetHeading2 = car2.heading; // Maintain current heading if too close
  } else {
    targetHeading2 = Math.atan2(dy2, dx2);
  }

  let headingError2 = targetHeading2 - car2.heading;
  while (headingError2 > Math.PI) headingError2 -= 2 * Math.PI;
  while (headingError2 < -Math.PI) headingError2 += 2 * Math.PI;

  // Debug NaN in steering
  if (isNaN(headingError2) || isNaN(targetHeading2) || isNaN(car2.heading)) {
    console.log("Car2 NaN detected: targetHeading=", targetHeading2, "dx=", dx2, "dy=", dy2, "car2.heading=", car2.heading, "path=", car2.path);
  }

  // Calculate steering with gain
  const isRejoining2 = (car2.path === "ellipse" && 
                      ((car2.y > centerY + car2.b - ROAD_WIDTH && car2.y < centerY + car2.b + ROAD_WIDTH) ||
                       (car2.y < centerY - car2.b + ROAD_WIDTH && car2.y > centerY - car2.b - ROAD_WIDTH)));
  const laneCenterForTransition2 = car2.verticalDirection === "up" ? UPWARD_LANE_X : DOWNWARD_LANE_X;
const isTransitioningToVertical2 = (car2.path === "vertical" && car2.y > centerY + car2.b - ROAD_WIDTH && Math.abs(car2.x - laneCenterForTransition2) > 2);
  car2.targetSteerAngle = headingError2 * STEERING_GAIN * ((car2.path === "vertical" && car2.verticalDirection === "up") || isTransitioningToVertical2 ? 2.5 : isRejoining2 || car2.path === "vertical" ? 2.0 : 1);
  car2.targetSteerAngle = isNaN(car2.targetSteerAngle) ? 0 : Math.max(-SYMMETRIC_MAX_TURN_STEER_ANGLE, Math.min(SYMMETRIC_MAX_TURN_STEER_ANGLE, car2.targetSteerAngle));

  // Update physics and clamp position to canvas
  updateCarPhysics(car2, currentSpeed2);
  car2.x = Math.max(0, Math.min(canvas.width, car2.x));
  car2.y = Math.max(0, Math.min(canvas.height, car2.y));
}

// resetSimulation function
function resetSimulation() {
  // Reset Car1
  car1.angle = -Math.PI / 2; // Start car1 at the top of the ellipse for clockwise movement
  car1.speed = 0.035; // Positive speed for physics update
  car1.steerAngle = 0;
  car1.targetSteerAngle = 0;
  car1.heading = 0; // Initial heading right (clockwise movement at top)
  car1.path = "ellipse";
  car1.verticalDirection = null;
  car1.canDecideAtTop = true;
  car1.canDecideAtBottom = true;

  // Calculate initial x, y based on angle for car1
  car1.x = centerX + car1.a * Math.cos(car1.angle);
  car1.y = centerY + car1.b * Math.sin(car1.angle);
  
  // Set initial rear and front axles based on initial x,y and heading for car1
  car1.rearX = car1.x - Math.cos(car1.heading) * WHEELBASE * 0.5;
  car1.rearY = car1.y - Math.sin(car1.heading) * WHEELBASE * 0.5;
  car1.frontX = car1.rearX + Math.cos(car1.heading) * WHEELBASE;
  car1.frontY = car1.rearY + Math.sin(car1.heading) * WHEELBASE;

  car1.lastLoggedHeading = car1.heading;
  car1.lastLoggedX = car1.x;
  car1.lastLoggedY = car1.y;

  // Reset Car2
  car2.angle = Math.PI;
  car2.speed = 0.035;
  car2.steerAngle = 0;
  car2.targetSteerAngle = 0;
  car2.heading = -Math.PI / 2;
  car2.path = "ellipse";
  car2.verticalDirection = null;
  car2.canDecideAtTop = true;
  car2.canDecideAtBottom = true;

  car2.x = centerX + car2.a * Math.cos(car2.angle);
  car2.y = centerY + car2.b * Math.sin(car2.angle);
  
  car2.rearX = car2.x - Math.cos(car2.heading) * WHEELBASE * 0.5;
  car2.rearY = car2.y - Math.sin(car2.heading) * WHEELBASE * 0.5;
  car2.frontX = car2.rearX + Math.cos(car2.heading) * WHEELBASE;
  car2.frontY = car2.rearY + Math.sin(car2.heading) * WHEELBASE;
  
  car2.lastLoggedHeading = car2.heading;
  car2.lastLoggedX = car2.x;
  car2.lastLoggedY = car2.y;

  console.clear();
  console.log("--- Simulation Reset ---");
}
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBackground();
      drawRoad();
      drawDashedEllipse(centerX, centerY, 400, 200);
      drawDashedLine(centerX, 200, centerX, 600);
      drawCar(car1);
      drawCar(car2);
      update();
      requestAnimationFrame(draw);
    }

    spriteSheet.onload = () => {
      resetSimulation(); 
      draw();
    };
    spriteSheet.onerror = () => {
      console.error('Sprite failed to load, using fallback rectangles.');
      resetSimulation(); 
      draw();
    };
  </script>
</body>
</html>
