<!DOCTYPE html>
<html>
<head>
  <title>Traffic Simulation</title>
  <style>
    body {
      background-color: #f0f0f0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      margin: 0;
      padding: 20px;
      font-family: sans-serif;
    }
    canvas {
      border: 1px solid black;
      display: block;
      margin: 0 auto;
      background-color: white;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    button {
      display: block;
      margin: 10px auto;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      border: none;
      background-color: #4CAF50;
      color: white;
      border-radius: 5px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      transition: background-color: 0.3s;
    }
    button:hover {
        background-color: #45a049;
    }
  </style>
</head>
<body>
  <canvas id="trafficCanvas" width="1300" height="900"></canvas>
  <button onclick="resetSimulation()">Reset Simulation</button>
  <button id="toggleSimulationButton" onclick="toggleSimulation()">Stop Simulation</button>

<script>
  const canvas = document.getElementById('trafficCanvas');
  const ctx = canvas.getContext('2d');
  const ROAD_WIDTH = 80 * 1.5;
  const CAR_SCALE = 0.1 * 1.5;
  const CAR_LENGTH = 518 * CAR_SCALE;
  const WHEELBASE = (409 - 94) * CAR_SCALE;
  const centerX = 650;
  const centerY = 450;
  const STEERING_GAIN = 0.5;
  const LOOK_AHEAD_DISTANCE = 90;
  const SYMMETRIC_MAX_TURN_STEER_ANGLE = Math.PI / 5;
  const LOG_HEADING_THRESHOLD_DEG = 5;
  const LOG_DISTANCE_THRESHOLD_PX = 25;
  const UPWARD_LANE_X = centerX + ROAD_WIDTH / 4;
  const DOWNWARD_LANE_X = centerX - ROAD_WIDTH / 4;
  const MAX_CENTRIFUGAL_FORCE = 0.01;
  const MAX_ACCELERATION = 0.08;
  const SPEED_SMOOTHING_FACTOR = 0.1;
  const STEERING_SMOOTHING_FACTOR = 0.1;
  const REJOIN_BUFFER_DISTANCE = ROAD_WIDTH;
  const DEBUG_LOG = false; // Enabled for debugging
  const USE_INTUITIVE_TURN_SIGNAL = true;
  const BLINKER_CYCLE_MS = 500;
  const BLINKER_ON_MS = BLINKER_CYCLE_MS / 2;
  const YIELD_TIMEOUT = 5000; // 5 seconds timeout for yielding

  // New tunable parameter for trajectory prediction
  const TRAJECTORY_LENGTH = 4.0; // In car lengths
  const APPROACH_DISTANCE = TRAJECTORY_LENGTH * CAR_LENGTH;

  // Declare car objects globally
  let car1 = {};
  let car2 = {};
  let car3 = {};
  let car4 = {};
  let car5 = {};
  let car6 = {};

  // Default properties for a car
  const CAR_DEFAULTS = {
    maximumSpeed: 0.05,
    speed: 0.05,
    currentSpeedFactor: 1.0,
    x: 0, y: 0,
    rearX: 0, rearY: 0, frontX: 0, frontY: 0,
    heading: 0,
    steerAngle: 0,
    targetSteerAngle: 0,
    lastLoggedHeading: 0,
    lastLoggedX: 0, lastLoggedY: 0,
    path: "ellipse",
    verticalDirection: null,
    direction: 1,
    isMakingTurn: false,
    turnDirection: null,
    rejoinBuffer: 0,
    turnState: null,
    canDecide: true,
    isYielding: false,
    yieldStartTime: 0,
    isCommittedToTurn: false,
    loggedCommit: false
  };

  // Helper to create a car object with default and specific properties
  function createCar(overrides) {
    return { ...CAR_DEFAULTS, ...overrides };
  }

function resetSimulation() {
    // Reset car1 (CW)
    Object.assign(car1, createCar({
        angle: 0, // Right side
        heading: Math.PI / 2, // Pointing up
        a: 560 - ROAD_WIDTH / 4,
        b: 360 - ROAD_WIDTH / 4,
        direction: 1
    }));

    // Reset car2 (CCW)
    Object.assign(car2, createCar({
        angle: Math.PI * 5 / 4,
        heading: Math.PI * 5 / 4 - Math.PI / 2, // Calculated based on angle for ellipse
        a: 560 + ROAD_WIDTH / 4,
        b: 360 + ROAD_WIDTH / 4,
        direction: -1
    }));

    // Reset car3 (CCW)
    Object.assign(car3, createCar({
        angle: Math.PI,
        heading: Math.PI - Math.PI / 2, // Calculated based on angle for ellipse
        a: 560 + ROAD_WIDTH / 4,
        b: 360 + ROAD_WIDTH / 4,
        direction: -1
    }));

    // Reset car4 (CW)
    Object.assign(car4, createCar({
        angle: Math.PI / 3,
        heading: Math.PI / 1.3, // Example fixed heading, consider dynamic calculation
        a: 560 - ROAD_WIDTH / 4,
        b: 360 - ROAD_WIDTH / 4,
        direction: 1
    }));

    // Reset car5 (CCW)
    Object.assign(car5, createCar({
        angle: -Math.PI / 2, // Top
        heading: Math.PI, // Pointing right
        a: 560 + ROAD_WIDTH / 4,
        b: 360 + ROAD_WIDTH / 4,
        direction: -1
    }));

    // Reset car6 (CW)
    Object.assign(car6, createCar({
        angle: Math.PI / 2, // Bottom
        heading: Math.PI, // Pointing left
        a: 560 - ROAD_WIDTH / 4,
        b: 360 - ROAD_WIDTH / 4,
        direction: 1
    }));

    // Initialize position and other calculated properties for all cars
    const allCars = [car1, car2, car3, car4, car5, car6];
    allCars.forEach(car => {
        car.x = centerX + car.a * Math.cos(car.angle);
        car.y = centerY + car.b * Math.sin(car.angle);
        car.rearX = car.x - Math.cos(car.heading) * WHEELBASE * 0.5;
        car.rearY = car.y - Math.sin(car.heading) * WHEELBASE * 0.5;
        car.frontX = car.rearX + Math.cos(car.heading) * WHEELBASE;
        car.frontY = car.rearY + Math.sin(car.heading) * WHEELBASE;
        car.lastLoggedHeading = car.heading;
        car.lastLoggedX = car.x;
        car.lastLoggedY = car.y;
    });

    if (DEBUG_LOG) {
      console.clear();
      console.log("--- Simulation Reset ---");
    }

    if (!isSimulationRunning) {
      isSimulationRunning = true;
      const button = document.getElementById('toggleSimulationButton');
      if (button) button.textContent = 'Stop Simulation';
    }

    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
    }
    gameLoop();
  }


  const spriteSheet = new Image();
  spriteSheet.src = 'https://vita2048.github.io/CityTrafficSimulator/CarSpritesheetLights.png';

  let animationFrameId = null;
  let isSimulationRunning = true;

  function drawBackground() {
    ctx.fillStyle = 'rgb(20, 140, 20)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  function drawRoad() {
    ctx.strokeStyle = '#666';
    ctx.fillStyle = '#666';
    ctx.lineWidth = ROAD_WIDTH;
    ctx.beginPath();
    ctx.ellipse(centerX, centerY, 560, 360, 0, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(centerX, 40);
    ctx.lineTo(centerX, 760);
    ctx.stroke();
  }

  function drawDashedEllipse(x, y, a, b) {
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.setLineDash([15, 15]);
    ctx.beginPath();
    ctx.ellipse(x, y, a, b, 0, 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  function drawDashedLine(x1, y1, x2, y2) {
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.setLineDash([15, 15]);
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.setLineDash([]);
  }


  function getDistance(carA, carB) {
    return Math.hypot(carA.x - carB.x, carA.y - carB.y);
  }

// --- NEW TRAJECTORY AND COLLISION HELPERS ---

// Helper function to get the four corners of a car's bounding box
function getCarBoundingBox(car) {
    const w = CAR_LENGTH / 2;
    const h = (230 * CAR_SCALE); // Approximate width of the car sprite
    const cosH = Math.cos(car.heading);
    const sinH = Math.sin(car.heading);

    const corners = [
        { x: -w, y: -h / 2 }, { x:  w, y: -h / 2 },
        { x:  w, y:  h / 2 }, { x: -w, y:  h / 2 }
    ];

    return corners.map(p => ({
        x: car.x + p.x * cosH - p.y * sinH,
        y: car.y + p.x * sinH + p.y * cosH
    }));
}

// Helper function to check if a point is inside a polygon (car's bounding box)
function isPointInPolygon(point, polygon) {
    let isInside = false;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;
        const intersect = ((yi > point.y) !== (yj > point.y))
            && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
        if (intersect) isInside = !isInside;
    }
    return isInside;
}

function checkTrajectoryIntersection(trajectory, otherCar) {
    const otherCarBox = getCarBoundingBox(otherCar);
    for (const state of trajectory) {
        const predictedStateCar = { x: state.x, y: state.y, heading: state.heading };
        const predictedBox = getCarBoundingBox(predictedStateCar);
        for (const predictedCorner of predictedBox) {
            if (isPointInPolygon(predictedCorner, otherCarBox)) {
                return true;
            }
        }
        for (const otherCorner of otherCarBox) {
            if (isPointInPolygon(otherCorner, predictedBox)) {
                return true;
            }
        }
    }
    return false;
}

// Define crossroad areas
const CROSSROAD_AREA_SIZE = ROAD_WIDTH * 2.5;
const topCrossroadArea = {
    x: centerX - CROSSROAD_AREA_SIZE / 2,
    y: centerY - 360 - CROSSROAD_AREA_SIZE / 2,
    width: CROSSROAD_AREA_SIZE,
    height: CROSSROAD_AREA_SIZE
};
const bottomCrossroadArea = {
    x: centerX - CROSSROAD_AREA_SIZE / 2,
    y: centerY + 360 - CROSSROAD_AREA_SIZE / 2,
    width: CROSSROAD_AREA_SIZE,
    height: CROSSROAD_AREA_SIZE
};

// Helper function to check if a trajectory intersects with a rectangular area
function checkTrajectoryVsArea(trajectory, area) {
    for (const point of trajectory) {
        if (point.x > area.x && point.x < area.x + area.width &&
            point.y > area.y && point.y < area.y + area.height) {
            return true;
        }
    }
    return false;
}

function getLookaheadPointForPrediction(car) {
    let targetX, targetY;

    if (car.turnState === 'rejoining' || (car.turnState === 'approaching' && car.path === 'vertical')) {
        const currentEllipseAngle = Math.atan2((car.y - centerY) / car.b, (car.x - centerX) / car.a);
        const lookAheadAngleOnEllipse = currentEllipseAngle + car.direction * (LOOK_AHEAD_DISTANCE / car.b);
        targetX = centerX + car.a * Math.cos(lookAheadAngleOnEllipse);
        targetY = centerY + car.b * Math.sin(lookAheadAngleOnEllipse);
    }
    else if (car.turnState === 'turning' || (car.turnState === 'approaching' && car.path === 'ellipse')) {
        if (car.y < centerY) {
            targetX = DOWNWARD_LANE_X;
            targetY = car.y + LOOK_AHEAD_DISTANCE;
        } else {
            targetX = UPWARD_LANE_X;
            targetY = car.y - LOOK_AHEAD_DISTANCE;
        }
    }
    else if (car.path === 'vertical') {
        let laneCenter = car.verticalDirection === "up" ? UPWARD_LANE_X : DOWNWARD_LANE_X;
        targetX = laneCenter;
        targetY = car.y + (car.verticalDirection === "down" ? LOOK_AHEAD_DISTANCE : -LOOK_AHEAD_DISTANCE);
    }
    else {
        const lookAheadAngle = car.angle + car.direction * (LOOK_AHEAD_DISTANCE / car.b);
        targetX = centerX + car.a * Math.cos(lookAheadAngle);
        targetY = centerY + car.b * Math.sin(lookAheadAngle);
    }

    return { targetX, targetY };
}

// Function to predict a car's future trajectory
function predictTrajectory(car) {
    const trajectory = [];
    const steps = 60;
    const totalDistance = TRAJECTORY_LENGTH * CAR_LENGTH;
    const stepLength = totalDistance / steps;

    let ghost = JSON.parse(JSON.stringify(car));

    const speed = car.maximumSpeed * 50 * car.currentSpeedFactor;
    if (speed < 0.1 && !car.isMakingTurn) {
         return trajectory;
    }

    for (let i = 0; i < steps; i++) {
        if (ghost.path === "ellipse") {
            ghost.angle = Math.atan2((ghost.y - centerY) / ghost.b, (ghost.x - centerX) / ghost.a);
        }

        const { targetX, targetY } = getLookaheadPointForPrediction(ghost);

        const dx = targetX - ghost.x;
        const dy = targetY - ghost.y;
        let targetHeading = (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1) ? ghost.heading : Math.atan2(dy, dx);

        let headingError = targetHeading - ghost.heading;
        while (headingError > Math.PI) headingError -= 2 * Math.PI;
        while (headingError < -Math.PI) headingError += 2 * Math.PI;
        if (isNaN(headingError)) headingError = 0;

        let steeringBoost = 1.0;
        const isRejoining = ghost.path === "ellipse" && ghost.verticalDirection !== null;
        if (ghost.path === "vertical" || isRejoining) {
            steeringBoost = 1.2;
        }

        ghost.targetSteerAngle = headingError * STEERING_GAIN * steeringBoost;
        ghost.targetSteerAngle = Math.max(-SYMMETRIC_MAX_TURN_STEER_ANGLE, Math.min(SYMMETRIC_MAX_TURN_STEER_ANGLE, ghost.targetSteerAngle));

        ghost.steerAngle += (ghost.targetSteerAngle - ghost.steerAngle) * STEERING_SMOOTHING_FACTOR;
        const MAX_STEER_CLAMP = Math.PI / 3;
        ghost.steerAngle = Math.max(-MAX_STEER_CLAMP, Math.min(MAX_STEER_CLAMP, ghost.steerAngle));

        const deltaHeading = Math.tan(ghost.steerAngle) * stepLength / WHEELBASE;
        ghost.heading += deltaHeading;
        while (ghost.heading > Math.PI) ghost.heading -= 2 * Math.PI;
        while (ghost.heading < -Math.PI) ghost.heading += 2 * Math.PI;

        ghost.rearX += Math.cos(ghost.heading) * stepLength;
        ghost.rearY += Math.sin(ghost.heading) * stepLength;

        ghost.x = ghost.rearX + Math.cos(ghost.heading) * WHEELBASE * 0.5;
        ghost.y = ghost.rearY + Math.sin(ghost.heading) * WHEELBASE * 0.5;

        // Add the full state (position and heading) to the trajectory array
        trajectory.push({ x: ghost.x, y: ghost.y, heading: ghost.heading });
    }
    return trajectory;
}

  function updateCarPhysics(car, speed) {
    car.steerAngle += (car.targetSteerAngle - car.steerAngle) * STEERING_SMOOTHING_FACTOR;
    const MAX_STEER_CLAMP = Math.PI / 3;
    car.steerAngle = Math.max(-MAX_STEER_CLAMP, Math.min(MAX_STEER_CLAMP, car.steerAngle));

    if (Math.abs(car.steerAngle) > 0.001) {
      const turnRadius = WHEELBASE / Math.tan(Math.abs(car.steerAngle));
      const currentVelocity = car.maximumSpeed * 50 * car.currentSpeedFactor;
      const centrifugalForce = (currentVelocity ** 2) / turnRadius;
      if (centrifugalForce > MAX_CENTRIFUGAL_FORCE) {
        const targetVelocity = Math.sqrt(MAX_CENTRIFUGAL_FORCE * turnRadius);
        car.currentSpeedFactor = Math.min(car.currentSpeedFactor, targetVelocity / (car.maximumSpeed * 50));
      }
    }

    if (Math.abs(car.steerAngle) > 0.001) {
      const deltaHeading = Math.tan(car.steerAngle) * speed / WHEELBASE;
      car.heading += deltaHeading;
      while (car.heading > Math.PI) car.heading -= 2 * Math.PI;
      while (car.heading < -Math.PI) car.heading += 2 * Math.PI;
    }

    car.rearX += Math.cos(car.heading) * speed;
    car.rearY += Math.sin(car.heading) * speed;

    car.frontX = car.rearX + Math.cos(car.heading) * WHEELBASE;
    car.frontY = car.rearY + Math.sin(car.heading) * WHEELBASE;

    car.x = car.rearX + Math.cos(car.heading) * WHEELBASE * 0.5;
    car.y = car.rearY + Math.sin(car.heading) * WHEELBASE * 0.5;

    if (car.path === "ellipse" && car.verticalDirection !== null) {
      car.rejoinBuffer += speed;
    }

    const carNames = [null, "Car1", "Car2", "Car3", "Car4", "Car5", "Car6"];
    const carNumber = [car1, car2, car3, car4, car5, car6].indexOf(car) + 1;
    const carName = carNames[carNumber];

    const headingDeg = car.heading * 180 / Math.PI;
    const lastHeadingDeg = car.lastLoggedHeading * 180 / Math.PI;
    const distTraveled = Math.hypot(car.x - car.lastLoggedX, car.y - car.lastLoggedY);

    if (DEBUG_LOG && (Math.abs(headingDeg - lastHeadingDeg) > LOG_HEADING_THRESHOLD_DEG || distTraveled > LOG_DISTANCE_THRESHOLD_PX)) {
      const turnRadius = Math.abs(car.steerAngle) > 0.001 ? WHEELBASE / Math.tan(Math.abs(car.steerAngle)) : Number.MAX_VALUE;
      console.log(`${carName} | Pos:(${Math.round(car.x)}, ${Math.round(car.y)}) | Head:${Math.round(headingDeg)}° | Steer:${Math.round(car.steerAngle * 180 / Math.PI)}° | Path:${car.path} | VertDir:${car.verticalDirection || 'none'} | SpeedFactor:${car.currentSpeedFactor.toFixed(3)} | TurnRadius:${turnRadius.toFixed(1)} | CentrifugalForce:${((car.maximumSpeed * 50 * car.currentSpeedFactor) ** 2 / (turnRadius || car.b)).toFixed(6)} | Yielding:${car.isYielding} | TurnState:${car.turnState} | TurnDir:${car.turnDirection || 'none'}`);
      car.lastLoggedHeading = car.heading;
      car.lastLoggedX = car.x;
      car.lastLoggedY = car.y;
    }
  }

  function drawTrajectory(car, trajectoryStates, turnType) {
    if (trajectoryStates.length < 2) return;

    let color = 'rgba(0, 255, 0, 0.05)'; // Green
    if (turnType === 'ellipse-to-vertical-left') {
        color = 'rgba(0, 0, 255, 0.05)'; // Blue
    } else if (turnType === 'vertical-to-ellipse-right') {
        color = 'rgba(255, 140, 0, 0.05)'; // Dark Orange ("Blue Amber")
    } else if (turnType === 'vertical-to-ellipse-left') {
        color = 'rgba(255, 69, 0, 0.05)';  // Orange-Red ("Red Amber")
    }
    ctx.fillStyle = color;

    const w = CAR_LENGTH / 2;
    const h = (230 * CAR_SCALE) / 2; // half-width

    for (const state of trajectoryStates) {
        const cosH = Math.cos(state.heading);
        const sinH = Math.sin(state.heading);

        const corners = [
            { x: -w, y: -h }, { x:  w, y: -h },
            { x:  w, y:  h }, { x: -w, y:  h }
        ];

        const transformedCorners = corners.map(p => ({
            x: state.x + p.x * cosH - p.y * sinH,
            y: state.y + p.x * sinH + p.y * cosH
        }));

        ctx.beginPath();
        ctx.moveTo(transformedCorners[0].x, transformedCorners[0].y);
        ctx.lineTo(transformedCorners[1].x, transformedCorners[1].y);
        ctx.lineTo(transformedCorners[2].x, transformedCorners[2].y);
        ctx.lineTo(transformedCorners[3].x, transformedCorners[3].y);
        ctx.closePath();
        ctx.fill();
    }
  }


  function drawCar(car) {
    const allCars = [car1, car2, car3, car4, car5, car6];
    const carNumber = allCars.indexOf(car) + 1;
    const carName = `Car${carNumber}`;

    ctx.save();
    ctx.translate(car.x, car.y);
    ctx.rotate(car.heading);
    ctx.scale(CAR_SCALE, CAR_SCALE);
    const frameWidth = 518;
    const frameHeight = 465;

    if (spriteSheet.complete && spriteSheet.naturalWidth > 0) {
      ctx.drawImage(spriteSheet, 0, 0, frameWidth, frameHeight, -259, -91.5, frameWidth, frameHeight);
    } else {
      let fillColor;
      if (car === car1) fillColor = 'red';
      else if (car === car2) fillColor = 'green';
      else if (car === car3) fillColor = 'blue';
      else if (car === car4) fillColor = 'purple';
      else if (car === car5) fillColor = 'orange';
	  else if (car === car6) fillColor = 'cyan';
      else fillColor = 'black';

      ctx.fillStyle = fillColor;
      ctx.fillRect(-259, -91.5, frameWidth, frameHeight);
    }

    ctx.fillStyle = 'red';
    ctx.font = 'bold 160px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(carNumber, 0, 0);


    let blinkerFrame = null;
    const isTurningOrRejoining = car.turnState === 'approaching' || car.turnState === 'turning' || car.turnState === 'rejoining';

    if (isTurningOrRejoining && car.turnDirection) {
      if (car.turnDirection === 'left') {
        blinkerFrame = { sx: 1 * frameWidth, sy: 1 * frameHeight };
      } else if (car.turnDirection === 'right') {
        blinkerFrame = { sx: 2 * frameWidth, sy: 1 * frameHeight };
      }

      const currentTime = performance.now();
      const cycleTime = currentTime % BLINKER_CYCLE_MS;
      const isBlinkerOn = cycleTime < BLINKER_ON_MS;

      if (blinkerFrame && isBlinkerOn && spriteSheet.complete && spriteSheet.naturalWidth > 0) {
        ctx.drawImage(
          spriteSheet,
          blinkerFrame.sx, blinkerFrame.sy, frameWidth, frameHeight,
          -259, -91.5, frameWidth, frameHeight
        );
      }

      if (DEBUG_LOG && blinkerFrame && (car.turnState === 'approaching' || car.turnState === 'turning' ||
          (car.turnState === 'rejoining' && (Math.abs(car.x - car.lastLoggedX) > 25 || Math.abs(car.y - car.lastLoggedY) > 25)))) {
        console.log(`${carName} displaying ${car.turnDirection} blinker: ${isBlinkerOn ? 'ON' : 'OFF'} at Pos:(${Math.round(car.x)}, ${Math.round(car.y)}), TurnState:${car.turnState}, TurnDirection:${car.turnDirection}`);
        car.lastLoggedX = car.x;
        car.lastLoggedY = car.y;
      }
    }

    if (typeof car.lastSpeedFactor === 'undefined') {
      car.lastSpeedFactor = car.currentSpeedFactor;
    }

    const isDecelerating = car.currentSpeedFactor < car.lastSpeedFactor || car.isYielding;
    if (isDecelerating && spriteSheet.complete && spriteSheet.naturalWidth > 0) {
      const brakeFrame = { sx: 0, sy: 1 * frameHeight };
      ctx.drawImage(
        spriteSheet,
        brakeFrame.sx, brakeFrame.sy, frameWidth, frameHeight,
        -259, -91.5, frameWidth, frameHeight
      );

      if (DEBUG_LOG && (Math.abs(car.x - car.lastLoggedX) > 25 || Math.abs(car.y - car.lastLoggedY) > 25)) {
        console.log(`${carName} displaying brake lights at Pos:(${Math.round(car.x)}, ${Math.round(car.y)}), SpeedFactor:${car.currentSpeedFactor.toFixed(3)}, LastSpeedFactor:${car.lastSpeedFactor.toFixed(3)}, Yielding:${car.isYielding}`);
      }
    }
    car.lastSpeedFactor = car.currentSpeedFactor;


    const predictedTrajectory = predictTrajectory(car);
    let turnType = 'straight';

    if (car.turnState === 'turning' || (car.turnState === 'approaching' && car.path === 'ellipse')) {
        if (car.turnDirection === 'left') {
            turnType = 'ellipse-to-vertical-left';
        }
    }
    else if (car.turnState === 'rejoining' || (car.turnState === 'approaching' && car.path === 'vertical')) {
        if (car.turnDirection === 'left') {
            turnType = 'vertical-to-ellipse-left';
        } else if (car.turnDirection === 'right') {
            turnType = 'vertical-to-ellipse-right';
        }
    }

	ctx.font = 'bold 80px sans-serif'; // Smaller font for additional info
	ctx.fillStyle = 'white'; // White for better visibility
	ctx.fillText(`Dir: ${car.direction === 1 ? 'CW' : 'CCW'}`, 0, 100);
	ctx.fillText(`VDir: ${car.verticalDirection || 'none'}`, 0, 180);
	ctx.fillText(`TurnType: ${car.turnType || 'none'}`, 0, 260); // turnType not used in car object, but kept for consistency
	ctx.fillText(`State: ${car.turnState || 'none'}`, 0, 340);
	ctx.fillText(`TurnDir: ${car.turnDirection || 'none'}`, 0, 420);
	ctx.fillText(`Path: ${car.path || 'none'}`, 0, 540);
	ctx.fillText(`CanDecide: ${car.canDecide}`, 0, 600);


	ctx.restore();

    drawTrajectory(car, predictedTrajectory, turnType);
  }


  function updateCar(car) {
    const allCars = [car1, car2, car3, car4, car5, car6];
    const carNumber = allCars.indexOf(car) + 1;
    const carName = `Car${carNumber}`;

    let currentSpeed = car.maximumSpeed * 50 * car.currentSpeedFactor;
    let targetX, targetY;

    car.angle = Math.atan2((car.y - centerY) / car.b, (car.x - centerX) / car.a);

    const isOnVerticalSegment = car.path === "vertical";
    let isRejoining = car.path === "ellipse" && car.verticalDirection !== null;

    const isNearTopCrossroad = car.path === "ellipse" && car.y < centerY && Math.abs(car.x - centerX) < APPROACH_DISTANCE;
    const isNearBottomCrossroad = car.path === "ellipse" && car.y > centerY && Math.abs(car.x - centerX) < APPROACH_DISTANCE;

    const isApproachingTopVerticalCrossroad = car.path === "vertical" && car.verticalDirection === "up" && car.y < (centerY - car.b) + APPROACH_DISTANCE;
    const isApproachingBottomVerticalCrossroad = car.path === "vertical" && car.verticalDirection === "down" && car.y > (centerY + car.b) - APPROACH_DISTANCE;

    const distToTop = Math.abs(car.y - (centerY - car.b));
    const distToBottom = Math.abs(car.y - (centerY + car.b));

    // Consolidated Turn Decision Logic
    if (car.canDecide && car.turnState === null) {
        if (isNearTopCrossroad) {
            car.isMakingTurn = Math.random() < 0.5;
            if (car.isMakingTurn) {
				car.turnDirection = (car.direction === -1) ? 'left' : 'right';// Ellipse to vertical
                car.turnState = 'approaching';
                if (DEBUG_LOG) console.log(`${carName} at top crossroad: will turn ${car.turnDirection}, turnState: approaching`);
            } else {
                car.turnDirection = 'straight'; // Continue on ellipse
                if (DEBUG_LOG) console.log(`${carName} at top crossroad: will go straight, turnState: null`);
            }
            car.canDecide = false;
        } else if (isNearBottomCrossroad) {
            car.isMakingTurn = Math.random() < 0.5;
            if (car.isMakingTurn) {
                car.turnDirection = (car.direction === -1) ? 'left' : 'right';// Ellipse to vertical
                car.turnState = 'approaching';
                if (DEBUG_LOG) console.log(`${carName} at bottom crossroad: will turn ${car.turnDirection}, turnState: approaching`);
            } else {
                car.turnDirection = 'straight'; // Continue on ellipse
                if (DEBUG_LOG) console.log(`${carName} at bottom crossroad: will go straight, turnState: null`);
            }
            car.canDecide = false;
        } else if (isApproachingTopVerticalCrossroad || isApproachingBottomVerticalCrossroad) {
            car.isMakingTurn = true; // Always turn to rejoin ellipse
            car.turnState = 'approaching';

            const randomTurn = Math.random() < 0.5 ? 'left' : 'right';
            car.turnDirection = randomTurn;

            const outerLaneA = 560 - ROAD_WIDTH / 4;
            const outerLaneB = 360 - ROAD_WIDTH / 4;
            const innerLaneA = 560 + ROAD_WIDTH / 4;
            const innerLaneB = 360 + ROAD_WIDTH / 4;

			if (randomTurn === 'left') { // Turn left to join inner, CCW lane
				car.direction = -1;
				car.a = innerLaneA;
				car.b = innerLaneB;
			} else { // Turn right to join outer, CW lane
				car.direction = 1;
				car.a = outerLaneA;
				car.b = outerLaneB;
			}


            car.canDecide = false;
            if (DEBUG_LOG) console.log(`%c${carName} approaching vertical rejoin: RANDOMLY chose ${car.turnDirection}, new lane direction ${car.direction}`, 'color: magenta; font-weight: bold;');
        }
    }


    const trajectory = predictTrajectory(car);
    let shouldStop = false;
    let collisionSlowdownFactor = 1.0;
    const frontBumperX = car.x + Math.cos(car.heading) * (CAR_LENGTH / 2);
    const frontBumperY = car.y + Math.sin(car.heading) * (CAR_LENGTH / 2);

	// --- FINAL, RESTRUCTURED COLLISION LOGIC BLOCK ---

	// Loop through all other cars to check for conflicts.
	for (const otherCar of allCars) {
		if (car === otherCar) continue;

		let mustYield = false;

		// --- 1. Special Case: Right-Turn Merge (Rule 2.1.1) ---
		if (car.isMakingTurn && car.path === 'vertical' && car.turnDirection === 'right' && (car.turnState === 'rejoining' || car.turnState === 'approaching')) {
			if (otherCar.path === 'ellipse' && otherCar.direction === 1) {
				const distance = getDistance(car, otherCar);
				if (distance < CAR_LENGTH * 4.0) {
					mustYield = true;
					if (DEBUG_LOG) console.log(`%c${carName} (Rule 2.1.1 Merge) yielding to Car${allCars.indexOf(otherCar) + 1} in proximity`, 'color: brown');
				}
			}
		}

		// --- 2. Trajectory-Based Checks (All Other Rules) ---
		const trajectoryOverlaps = checkTrajectoryIntersection(trajectory, otherCar);
		if (trajectoryOverlaps) {
			const distance = getDistance(car, otherCar);
			const reactionDistance = TRAJECTORY_LENGTH * CAR_LENGTH;
			const proximity = Math.max(0, (reactionDistance - distance) / reactionDistance);
			collisionSlowdownFactor = Math.min(collisionSlowdownFactor, 1.0 - proximity * 0.9);

			let ruleTriggered = false;

			// RULE 1: Same-lane following
			let isAheadInLane = false;
			if (car.path === 'ellipse' && otherCar.path === 'ellipse' && car.direction === otherCar.direction) {
				let angleDiff = car.direction === 1 ? (otherCar.angle - car.angle) : (car.angle - otherCar.angle);
				if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
				isAheadInLane = angleDiff > 0 && angleDiff < Math.PI / 2;
			} else if (car.path === 'vertical' && otherCar.path === 'vertical' && car.verticalDirection === otherCar.verticalDirection) {
				isAheadInLane = (car.verticalDirection === 'up' && otherCar.y < car.y) || (car.verticalDirection === 'down' && otherCar.y > car.y);
			}
			if (isAheadInLane && distance < CAR_LENGTH * 1.4) {
				 ruleTriggered = true;
				 if (DEBUG_LOG) console.log(`%c${carName} (Rule 1) yielding to Car${allCars.indexOf(otherCar) + 1} ahead`, 'color: gray');
			}

			// RULE 2.1.2 (Left Turn from Vertical)
			const isPerformingVerticalToEllipseLeftTurn = car.isMakingTurn && car.turnDirection === 'left' && 
				(car.turnState === 'rejoining' || (car.turnState === 'approaching' && car.path === 'vertical'));

			if (isPerformingVerticalToEllipseLeftTurn) {
				if (otherCar.path === 'ellipse' || otherCar.isMakingTurn) {
					ruleTriggered = true;
					if (DEBUG_LOG) console.log(`%c${carName} (Rule 2.1.2) yielding to Car${allCars.indexOf(otherCar) + 1} during left rejoin`, 'color: red; font-weight: bold;');
				}
			}

			// RULE 2.2 (Left Turn from Ellipse)
			const isPerformingEllipseToVerticalLeftTurn = car.isMakingTurn && car.turnDirection === 'left' &&
				(car.turnState === 'turning' || (car.turnState === 'approaching' && car.path === 'ellipse'));
			if (isPerformingEllipseToVerticalLeftTurn) {
				const mustYieldToThisCar = otherCar.turnState !== 'rejoining';

				if (mustYieldToThisCar) {
					const isConflictingVehicle = (otherCar.path === 'ellipse' && otherCar.direction !== car.direction) || (otherCar.isMakingTurn);
					if (isConflictingVehicle) {
						ruleTriggered = true;
						if (DEBUG_LOG) console.log(`%c${carName} (Rule 2.2) yielding to Car${allCars.indexOf(otherCar) + 1}`, 'color: blue');
					}
				}
			}

			if (ruleTriggered) {
				mustYield = true;
			}
		}

		if (mustYield) {
			shouldStop = true;
		}
	}

    // --- COMMIT AND YIELDING LOGIC (REVISED) ---
    // STEP 1: Set yielding state based on collision check.
    car.isYielding = shouldStop;
    if (car.isYielding) {
        if (!car.yieldStartTime) car.yieldStartTime = performance.now();
    } else {
        car.yieldStartTime = 0; // Reset timer if not yielding
    }

    // Handle yield timeout: if stuck yielding for too long, proceed anyway.
    if (car.isYielding && performance.now() - car.yieldStartTime > YIELD_TIMEOUT) {
        car.isYielding = false;
        shouldStop = false; // Override the stop decision
        car.yieldStartTime = 0;
        if (DEBUG_LOG) console.log(`%c${carName} yield timeout, resuming.`, 'color: orange');
    }

    // STEP 2: Check if the car is currently positioned AT a yield line.
    let isAtYieldLine = false;
    if (!car.isCommittedToTurn) { // Only check for stopping if not already committed        
        // A) Check for yield line when turning from ELLIPSE to VERTICAL (Left Turn) - This is a left turn from the ellipse *onto* the vertical road.
        if (car.path === 'ellipse' && car.isMakingTurn && car.turnDirection === 'left') {
            // Requirement: Stop where front bumper aligns with the edge of the vertical road.
            const frontBumperX = car.x + Math.cos(car.heading) * (CAR_LENGTH / 2);
            const VERTICAL_ROAD_LEFT_EDGE = centerX - ROAD_WIDTH / 2;
            const VERTICAL_ROAD_RIGHT_EDGE = centerX + ROAD_WIDTH / 2;

            if (car.x > centerX) { // Car is on the right half of the ellipse
                // It is moving left to enter the intersection. Stop before crossing the right edge.
                if (frontBumperX <= VERTICAL_ROAD_RIGHT_EDGE) {
                    isAtYieldLine = true;
                    if (DEBUG_LOG) console.log(`%c${carName} at Ellipse-to-Vertical LEFT RIGHT-SIDE YIELD LINE. FBX:${frontBumperX.toFixed(0)} <= ${VERTICAL_ROAD_RIGHT_EDGE}`, 'color: green;');
                }
            } else { // Car is on the left half of the ellipse
                // It is moving right to enter the intersection. Stop before crossing the left edge.
                if (frontBumperX >= VERTICAL_ROAD_LEFT_EDGE) {
                    isAtYieldLine = true;
                    if (DEBUG_LOG) console.log(`%c${carName} at Ellipse-to-Vertical LEFT LEFT-SIDE YIELD LINE. FBX:${frontBumperX.toFixed(0)} >= ${VERTICAL_ROAD_LEFT_EDGE}`, 'color: green;');
                }
            }
        }
        // B) Check for yield line when turning from VERTICAL to ELLIPSE (Rejoin)
        const isVerticalManeuver = car.isMakingTurn && (car.path === 'vertical' || car.turnState === 'rejoining');
        if (isVerticalManeuver) {
            const carFrontY = car.y + Math.sin(car.heading) * (CAR_LENGTH / 2); // Front of the car along its heading
            // Requirement: Stop where front bumper aligns with innermost edge of the entire elliptical road.
            const ELLIPSE_B_MAIN = 360; // Use the main road radius for the physical line
            const yieldLineTop = centerY - (ELLIPSE_B_MAIN - ROAD_WIDTH / 2);
            const yieldLineBottom = centerY + (ELLIPSE_B_MAIN - ROAD_WIDTH / 2);
            if (car.verticalDirection === 'up' && carFrontY <= yieldLineTop) {
                isAtYieldLine = true;
                if (DEBUG_LOG) console.log(`%c${carName} at Vertical Up Rejoin YIELD LINE. FBY:${carFrontY.toFixed(0)} <= ${yieldLineTop.toFixed(0)}`, 'color: green;');
            } else if (car.verticalDirection === 'down' && carFrontY >= yieldLineBottom) {
                isAtYieldLine = true;
                if (DEBUG_LOG) console.log(`%c${carName} at Vertical Down Rejoin YIELD LINE. FBY:${carFrontY.toFixed(0)} >= ${yieldLineBottom.toFixed(0)}`, 'color: green;');
            }
        }
    }

    // STEP 3: If a car is already committed to a turn, it should NOT stop.
    if (car.isCommittedToTurn) {
        shouldStop = false;
        car.isYielding = false;
        if (DEBUG_LOG && !car.loggedCommit) {
             console.log(`%c${carName} IS COMMITTED, WILL NOT YIELD`, 'color: yellow; font-weight: bold;');
             car.loggedCommit = true;
        }
    }

    // STEP 4: Decide if a hard stop should be performed in THIS frame.
    const performHardStop = shouldStop && isAtYieldLine;

    // STEP 5: Calculate the car's target speed factor.
    let targetSpeedFactor = 1.0;
    
    let predictedTurnRadius = car.b;
    if (car.isMakingTurn && car.path === 'ellipse' && (isNearTopCrossroad || isNearBottomCrossroad)) {
      predictedTurnRadius = ROAD_WIDTH / 2;
    } else if (isOnVerticalSegment) {
        const approachingBottomRejoin = car.verticalDirection === "down" && car.y > centerY + car.b - APPROACH_DISTANCE;
        const approachingTopRejoin = car.verticalDirection === "up" && car.y < centerY - car.b + APPROACH_DISTANCE;
        if (approachingBottomRejoin || approachingTopRejoin) {
            predictedTurnRadius = car.b;
            if(!car.isCommittedToTurn) car.turnState = 'rejoining';
        } else {
            predictedTurnRadius = Number.MAX_VALUE;
        }
    }
    const currentVelocityForDecel = car.maximumSpeed * 50 * car.currentSpeedFactor;
    const targetVelocityForTurn = Math.sqrt(predictedTurnRadius * MAX_CENTRIFUGAL_FORCE);
    const decelerationDistance = Math.abs(currentVelocityForDecel - targetVelocityForTurn) / MAX_ACCELERATION * 4;

    if ((isNearTopCrossroad && car.isMakingTurn && distToTop <= decelerationDistance) ||
        (isNearBottomCrossroad && car.isMakingTurn && distToBottom <= decelerationDistance) ||
        (isOnVerticalSegment && ((car.verticalDirection === "down" && car.y > centerY + car.b - decelerationDistance) || (car.verticalDirection === "up" && car.y < centerY - car.b + decelerationDistance)))) {
      targetSpeedFactor = Math.min(1.0, targetVelocityForTurn / (car.maximumSpeed * 50));
    }

    targetSpeedFactor = Math.min(targetSpeedFactor, collisionSlowdownFactor);

    // STEP 6: Apply the final speed for this frame.
    if (performHardStop) {
        car.currentSpeedFactor = 0;
    } else {
        if (car.currentSpeedFactor < targetSpeedFactor) {
            car.currentSpeedFactor = Math.min(targetSpeedFactor, car.currentSpeedFactor + MAX_ACCELERATION / (car.maximumSpeed * 50));
        } else {
            car.currentSpeedFactor += (targetSpeedFactor - car.currentSpeedFactor) * SPEED_SMOOTHING_FACTOR;
        }
    }

    // STEP 7: AFTER all speed decisions are made, update the commitment state for the NEXT frame.
    if (!car.isCommittedToTurn) { 
        let isPastCommitPoint = false;

        // Case A: Ellipse-to-Vertical Turn
        if (car.path === 'ellipse' && car.isMakingTurn && car.turnDirection === 'left') {
            const VERTICAL_ROAD_LEFT_EDGE = centerX - ROAD_WIDTH / 2;
            const VERTICAL_ROAD_RIGHT_EDGE = centerX + ROAD_WIDTH / 2;
            // Commit once the car's center is inside the vertical road area.
            if ((car.x > centerX && car.x < VERTICAL_ROAD_RIGHT_EDGE) || (car.x < centerX && car.x > VERTICAL_ROAD_LEFT_EDGE)) {
                isPastCommitPoint = true;
                if (DEBUG_LOG) console.log(`%c${carName} PASSED COMMIT POINT (Ellipse-to-Vertical) at X:${car.x.toFixed(0)}`, 'color: fuchsia');
            }
        }

        // Case B: Vertical-to-Ellipse Turn (Rejoin)
        const isVerticalManeuverForCommit = car.isMakingTurn && (car.path === 'vertical' || car.turnState === 'rejoining');
        if (isVerticalManeuverForCommit) {
             // Commit point is the inner edge of the car's *target lane*, not the whole road.
             const commitLineTop = centerY - (car.b - ROAD_WIDTH / 2);
             const commitLineBottom = centerY + (car.b - ROAD_WIDTH / 2);

             if ((car.verticalDirection === 'up' && car.y < commitLineTop) || (car.verticalDirection === 'down' && car.y > commitLineBottom)) {
                isPastCommitPoint = true;
                if (DEBUG_LOG) console.log(`%c${carName} PASSED COMMIT POINT (Vertical-to-Ellipse) at Y:${car.y.toFixed(0)}`, 'color: fuchsia');
             }
        }

        if (isPastCommitPoint) {
            car.isCommittedToTurn = true;
        }
    }

    currentSpeed = car.maximumSpeed * 50 * car.currentSpeedFactor;

    // Path guidance logic
    if (car.isMakingTurn && car.path === 'ellipse' && car.turnState !== 'rejoining') {
        const isAtTopIntersection = Math.abs(car.x - centerX) < ROAD_WIDTH * 0.9 && car.y < centerY;
        const isAtBottomIntersection = Math.abs(car.x - centerX) < ROAD_WIDTH * 0.9 && car.y > centerY;

        if (isAtTopIntersection) {
            car.path = "vertical";
            car.verticalDirection = "down";
            car.turnState = 'turning';
            targetX = DOWNWARD_LANE_X;
            targetY = car.y + LOOK_AHEAD_DISTANCE;

        } else if (isAtBottomIntersection) {
            car.path = "vertical";
            car.verticalDirection = "up";
            car.turnState = 'turning';
            targetX = UPWARD_LANE_X;
            targetY = car.y - LOOK_AHEAD_DISTANCE;
        } else { 
            const lookAheadAngle = car.angle + car.direction * car.speed * 5;
            targetX = centerX + car.a * Math.cos(lookAheadAngle);
            targetY = centerY + car.b * Math.sin(lookAheadAngle);
        }
    } else if (isOnVerticalSegment) {
        let laneCenter = car.verticalDirection === "up" ? UPWARD_LANE_X : DOWNWARD_LANE_X;
        targetX = laneCenter;
        targetY = car.y + (car.verticalDirection === "down" ? LOOK_AHEAD_DISTANCE : -LOOK_AHEAD_DISTANCE);

        const headingError = Math.abs(car.heading - (car.verticalDirection === "up" ? -Math.PI / 2 : Math.PI / 2));
        if (headingError < Math.PI / 10 && Math.abs(car.x - laneCenter) < ROAD_WIDTH / 4 && car.turnState === 'turning') {
            car.turnState = null;
            car.isMakingTurn = false;
			car.canDecide = true;
			car.turnDirection = null;
            car.isCommittedToTurn = false;
            car.loggedCommit = false;
        }

		if ((car.verticalDirection === "down" && car.y > centerY + car.b - ROAD_WIDTH / 2) ||
			(car.verticalDirection === "up" && car.y < centerY - car.b + ROAD_WIDTH / 2)) {
			if (!car.isCommittedToTurn) {
				car.turnState = 'rejoining';
			}
			if (car.isCommittedToTurn) {
				car.path = "ellipse";
				car.angle = Math.atan2((car.y - centerY) / car.b, (car.x - centerX) / car.a);
				const lookAheadAngle = car.angle + car.direction * car.speed * 5;
				targetX = centerX + car.a * Math.cos(lookAheadAngle);
				targetY = centerY + car.b * Math.sin(lookAheadAngle);
			}
		}

    } else { // On elliptical path, not turning to vertical
        car.path = "ellipse";
        if (!isRejoining) {
            car.angle = Math.atan2((car.y - centerY) / car.b, (car.x - centerX) / car.a);
        }
        const lookAheadAngle = car.angle + car.direction * car.speed * 5;
        targetX = centerX + car.a * Math.cos(lookAheadAngle);
        targetY = centerY + car.b * Math.sin(lookAheadAngle);

        const radialDistance = Math.hypot(car.x - centerX, (car.y - centerY) * car.a / car.b);
        const isOnEllipse = Math.abs(radialDistance - car.a) < ROAD_WIDTH / 2;

        if (isRejoining && isOnEllipse && car.rejoinBuffer > REJOIN_BUFFER_DISTANCE) {
            if(DEBUG_LOG) console.log(`${carName} has completed rejoin maneuver.`);
            car.verticalDirection = null;
            car.rejoinBuffer = 0;
            car.turnState = null;
            car.isMakingTurn = false;
            car.turnDirection = null;
            isRejoining = false;
            car.isCommittedToTurn = false; 
            car.loggedCommit = false;
        }

        if (car.y > centerY - car.b + 2 * ROAD_WIDTH && car.y < centerY + car.b - 2 * ROAD_WIDTH) {
            car.canDecide = true;
        }


	}


  const dx = targetX - car.x;
  const dy = targetY - car.y;
  let targetHeading = (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1) ? car.heading : Math.atan2(dy, dx);

  let headingError = targetHeading - car.heading;
  while (headingError > Math.PI) headingError -= 2 * Math.PI;
  while (headingError < -Math.PI) headingError += 2 * Math.PI;
  if (isNaN(headingError)) headingError = 0;

  let steeringBoost = 1.0;
  if (isOnVerticalSegment || isRejoining) {
    steeringBoost = 1.2;
  }

  car.targetSteerAngle = headingError * STEERING_GAIN * steeringBoost;
  car.targetSteerAngle = Math.max(-SYMMETRIC_MAX_TURN_STEER_ANGLE, Math.min(SYMMETRIC_MAX_TURN_STEER_ANGLE, car.targetSteerAngle));

  updateCarPhysics(car, currentSpeed);
  car.x = Math.max(0, Math.min(canvas.width, car.x));
  car.y = Math.max(0, Math.min(canvas.height, car.y));
}
    // Function to draw crossroad areas for debugging
  function drawCrossroadAreas() {
    ctx.save();
    ctx.globalAlpha = 0.2;
    ctx.fillStyle = 'purple';
    ctx.fillRect(topCrossroadArea.x, topCrossroadArea.y, topCrossroadArea.width, topCrossroadArea.height);
    ctx.fillRect(bottomCrossroadArea.x, bottomCrossroadArea.y, bottomCrossroadArea.height, bottomCrossroadArea.height);
    ctx.restore();
  }

  function gameLoop() {
    if (!isSimulationRunning) return;

    update();
    draw();

    animationFrameId = requestAnimationFrame(gameLoop);
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBackground();
    drawRoad();
    drawDashedEllipse(centerX, centerY, 560, 360);
    drawDashedLine(centerX, 90, centerX, 810);
    drawCar(car1);
    drawCar(car2);
    drawCar(car3);
	drawCar(car4);
    drawCar(car5);
	drawCar(car6);
    drawCrossroadAreas();
  }

  function update() {
    updateCar(car1);
    updateCar(car2);
    updateCar(car3);
	updateCar(car4);
    updateCar(car5);
	updateCar(car6);
  }

  function toggleSimulation() {
    const button = document.getElementById('toggleSimulationButton');
    isSimulationRunning = !isSimulationRunning;
    if (isSimulationRunning) {
      button.textContent = 'Stop Simulation';
      if (DEBUG_LOG) console.log("--- Simulation Resumed ---");
      gameLoop();
    } else {
      button.textContent = 'Resume Simulation';
      if (DEBUG_LOG) console.log("--- Simulation Paused ---");
      cancelAnimationFrame(animationFrameId);
    }
  }

  spriteSheet.onload = () => {
    resetSimulation();
  };
  spriteSheet.onerror = () => {
    console.error('Sprite failed to load, using fallback rectangles.');
    resetSimulation();
  };
</script>
</body>
</html>
